# 代码记录

## 第一周

### 跨域问题

之前实现跨域都是后端直接CROS完成的，自己前端没有实现过，也是搞了半天（~~服了~~）

主要理解前端实现跨域原理：

我们要知道，跨域的由来，即为什么会有跨域问题？？？这是因为"古时候"还没有前后端分离的概念，即前端和后端资源都是在一起的，而前后端分离之后，前后端资源就不放在一起了，那么由于浏览器的安全策略，不允许不同源的资源进行访问

前后端资源都不在一起，那么必然就触发浏览器的该同源策略了呗

那么前端要解决跨域问题，原理在于跨过浏览器

以Vue3为例是使用proxy代理解决的

我们知道项目启动时nodejs会启动一个端口，而这个地址就会变成我们与后端交互的"中间人"

那么，我们前端只需把请求发送到该地址(nodejs)，再让该地址把我们的请求发送到后端，后端返回结果给中间人，中间人再给我们前端就好了

这其中，前端从直接向后端发请求，变成了向本地node代理服务器发请求(该服务器在本地因此是同源的)，这样就实现了绕过浏览器的同源策略了，也就解决了跨域问题





### Script标签引入所带来的顺序问题

- 起因是项目需要接入腾讯地图的地图api，而经查询腾讯地图在Vue中只能通过script标签引入，这里就带来了一些代码执行顺序问题
  - bug：我直接在setup的script标签中执行有关引入文件的代码，导致script标签引入的外部文件还没完全导入，因此代码报错找不到变量
  - 最后解决办法是：将有关引入内容的代码移到对应模块打开之后（即放到某个生命周期钩子里）

> 引发思考（你知道 script 标签脚本在各种情况下的加载和执行顺序吗？）：
>
> 首先清楚，script类型有哪些？？？
>
> 1. 内联脚本script（即script标签内直接写JS代码）
>
> 浏览器在解析 `html` 代码时，遇到上面的 `script` 标签时：
>
> 1. 暂停 DOM 解析过程
> 2. 执行 JS 代码
> 3. 执行完成，继续 DOM 解析过程
>
> 该过程的时序图如下：
>
> ![img](bug记录.assets/v2-d31ac7705fa2590e8919e66054e18cd1_720w.webp)
>
> 2. 外部脚本（即script标签使用src属性引入外部链接）
>
> 浏览器在解析 `html` 代码时遇到上面的 `script` 标签时：
>
> 1. 暂停 DOM 解析过程
> 2. 加载 a.js
> 3. 加载完成后，开始执行该脚本
> 4. 执行完成，继续 DOM 解析过程
>
> 该过程的时序图如下：
>
> ![img](bug记录.assets/v2-d9a5982a54eda847cd8e2b7f2802f3c8_720w.webp)
>
> -------
>
> 上述提到的内联脚本与外部脚本，DOM解析过程中都会被打断，我们称这种方式是``同步阻塞``的
>
> 当外部脚本文件太大时，加载过程中用户会看到页面一片空白，我们称之为“白屏”现象。有一种简单的解决方式是把 script 标签插入到 body 的底部：
>
> 这种方式可以让浏览器先解析之前的内容，解析完成之后才来加载和执行 JS 脚本，过程如下：
>
> ![img](bug记录.assets/v2-1500b7027848d86f8e6bce572516dada_720w.webp)
>
> 但是``加载JS``这一步骤并不那么重要，我们关心的是什么时候``执行JS``，因此出现了``defer/async``这两个属性来控制``加载JS``与解析DOM并行
>
> 此时：
>
> 我们把该 `script` 标签写在 `head` 里面，让浏览器尽快 `加载js` ：
>
> ```html
> <html>
> <head>
>     <script defer src="./a.js"></script>
> </head>
> </html>
> ```
>
> 该过程的时序图如下：
>
> ![img](bug记录.assets/v2-b0fb966ce60a966ea1f346ab3d16d187_720w.webp)
>
> 使用``defer``导致执行JS会被延迟到解析DOM完成之后
>
> 如果想要尽快执行JS代码，那么可以使用``async``属性
>
> ```js
> <script async src="./a.js"></script>
> ```
>
> 该过程的时序图如下：
>
> ![img](bug记录.assets/v2-cb57f17a380a2e9151fc05abcd9375bb_720w.webp)
>
> ------
>
> 一般我们不会同时指定``async``属性与``defer``属性，如果同时指定，``async``的优先级会更高
>
> ------
>
> 如果是es module模块脚本呢
>
> 我们通过指定 `type="module"` 来声明一个外部脚本是一个 `es` 模块：
>
> ```html
> <script type="module" src="./a.mjs"></script>
> ```
>
> 对于 `es` 模块脚本，它默认是 `defer` 的。为什么？因为 `es modules` 脚本它的依赖分析是静态的，也就是说浏览器加载了 `a.mjs` 之后，还要分析 `a.mjs` 模块通过 `import` 导入的其他依赖的模块。分别，如果 `a.mjs` 还 `import` 了 `b.mjs` 和 `c.mjs` ：
>
> ```js
> // a.mjs
> import b from "./b.mjs"
> import c from "./c.mjs"
> ```
>
> 浏览器加载 `a.mjs` 之后，还需要继续加载 `b.mjs` 和 `c.mjs` 。只有所有这些依赖模块都分析加载完毕，才能开始执行其中的 `js` 脚本，而且根据根据 `es modules` 的规则，浏览器会先执行 `b.mjs` 中的代码，然后是 `c.mjs` ，最后才是 `a.mjs` 的代码。
>
> ![img](bug记录.assets/v2-3b6f3eba82af88fd3849d544342e1f3f_720w.webp)
>
> 总结：
>
> ![img](bug记录.assets/v2-8df9d864a263990fee83b48b29c987ad_720w.webp)
>
> [参考自：你知道 script 标签脚本在各种情况下的加载和执行顺序吗？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/464633848)



### 代码执行顺序问题





### emit顺序问题

- 组件内emit的顺序也需要注意，今天就遇到对应的bug了（~~改了几个小时，最后还是组长帮我发现的五五~~
- 即我们有时候需要父子组件双向绑定的情况，因此需要``emit('update:modelValue')``，但是有时候还需要传出change事件，因此还会``emit('change')``，这个时候一般这两个emit会写在一起，但是顺序很重要！！！
- 例如在父组件中需要在change事件中对双向绑定的值进行访问，那么我们就要优先``emit('update:modelValue')``，否则就会出现在父组件change事件中，访问不到绑定的值的情况（~~血的教训~~







### 组件封装好处

- 今天在使用封装的table组件时（对组件库table组件的封装），在组件事件传出事件对象或其他数据时，可能存在该数据并不是我们想要的数据，因此封装起来的好处就是，可以调整事件本身传出的参数即传出最方便我们的参数
  - 例如该需求是完成点击按钮进行排序，该组件库的组件对应点击事件传出的参数是tableColumn对应对象所设置的key，但是该key可能并不是排序接口所需要的值
  - 因此，我们可以重新在父组件就在column数据中专门为接口的"key"设置一个"sortKey"并且设置值为排序接口的那个字段，这样就完美解决了字段名不一致的问题（~~后端也不设置一样的字段真是的~~）




### ref与reactive的区别

今天写代码的时候，需要声明一个响应式对象，想着~~偷懒~~不用写``.value`	``，然后就出bug了。。。

原因就是，在后续逻辑中直接对reactive声明的响应式对象直接赋值一个对象了

复习``reactive``的局限性：

1. **有限的值类型**：它只能用于**复杂类型 (对象、数组和如 `Map`、`Set` 这样的集合类型](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#keyed_collections)**)。它不能持有如 `string`、`number` 或 `boolean` 这样的[原始类型](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)。

2. **不能替换整个对象**：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失：

   ```js
   let state = reactive({ count: 0 })

   // 上面的 ({ count: 0 }) 引用将不再被追踪
   // (响应性连接已丢失！)
   state = reactive({ count: 1 })
   ```

3. **对解构操作不友好**：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接：

   ```js
   const state = reactive({ count: 0 })

   // 当解构时，count 已经与 state.count 断开连接
   let { count } = state
   // 不会影响原始的 state
   count++

   // 该函数接收到的是一个普通的数字
   // 并且无法追踪 state.count 的变化
   // 我们必须传入整个对象以保持响应性
   callSomeFunction(state.count)
   ```

所以没事还是用ref就好





### v-bind动态绑定多个值

今天发现公司项目代码中的一个写法，在组件标签上直接``v-bind="field.config"``，看了Vue文档，才发现这种写法是可以动态绑定多个值的，即``field.config``是一个对象，那么对象中的每一个键值对都会传给子组件了

```js
const objectOfAttrs = {
  id: 'container',
  class: 'wrapper'
}
<MyComponent v-bind="objectOfAttrs"><MyComponent/>
// 相当于
<MyComponent v-bind:id="container" v-bind:class="wrapper"><MyComponent/>
```







## 第二周

### dialog获取DOM元素的问题

起因：今天有个需求是需要在dialog组件退出后将页面的滚动条重置为顶部，但是因为使用的是第三方组件库arco-designer的dialog，怎么样都无法通过dialog组件的ref获取到对应的组件DOM元素，最后结论是可能原因出自于组件内部本身就不允许这样做/或者是组件内部使用了Teleport将DOM结构改变了，解决办法是重新在滚动条区域外包一层div用于获取DOM元素





### Vue3中v-if与v-for同时使用带来的问题

如下是一个例子

```vue
<div v-for="item in textValue" :key="item.text" v-if="item.show">
      {{ item.text }}
    </div>


textValue: [{ text: '宫保鸡丁', show: true }, 
			{ text: '黄焖鸡米饭', show: true }, 
			{ text: '黄焖鸡米饭', show: true }, 
			{ text: '重庆小面', show: false }, 
			{ text: '蚂蚁上树', show: true }],

```

在 Vue 中，`v-for` 和 `v-if` 同时使用在同一个元素上是不推荐的，主要有以下几个原因：

1. **可读性**：当 `v-for` 和 `v-if` 同时存在于同一个元素时，会使代码变得难以理解。`v-if` 有更高的优先级，这意味着 `v-if` 的条件将无法访问到 `v-for` 作用域内定义的变量别名。
2. **性能**：`v-if` 是一个成本较高的操作，因为它涉及到真实 DOM 的创建和销毁。如果在 `v-for` 循环中使用 `v-if`，可能会导致性能问题，因为每次循环都可能触发 DOM 的更新。

- 解决方案


1. 在外层嵌套template（使得页面渲染但不生成DOM节点）

```vue
<template v-for="item in textValue">
      <div :key="item.text" v-if="item.show" >{{item.text}}</div>
</template>
```

2. 使用计算属性提前过滤不需要的内容


```js
const dataFilter = computed(() => {
      return data.textValue.filter((res: any) => {
        return res.show !== false
    })
 })
```





### dialog组件内部嵌套组件的滚动条重置问题

先说最终的解决方案是为该嵌套组件添加变化的随时间戳变化的key``:key="new Date().getTime()"``使得每次该组件都可以被重载，从而实现滚动条重置（消耗一些性能）

原先的解决方案是：将外层dialog组件的visible(控制dialog的显示隐藏)传入该嵌套组件，嵌套组件内即可监听到dialog的关闭从而重置滚动条（但是！组件的使用是为了更好的复用，该嵌套组件未来有可能不在dialog中使用，那么这个传入这个visible在组件内的意义就不是复用了，而是单独为了在dialog中使用而使用）

更好的解决方案，在beforeClose钩子中进行重置即可



### nextTick的使用

之前对``nextTick``的认识：即延迟某些操作到下次DOM更新，nextTick存在的原因是Vue中对DOM的更新是异步的，即``确保不管你进行了多少次状态修改，每个组件都只会被更新一次``，实际上我对该方法的使用都是错误的

```js
nextTick()//错误！！！
// DOM操作
```

注意：nextTick()函数会返回一个Promise，即该函数是异步的！！！

正确使用：

1. 传入回调函数

```js
// 传入nextTick函数一个回调函数，那么你提供的回调函数将会在DOM更新后执行
nextTick(()=>{})
// 但是！nextTick()之后的代码会立即执行，不会等待DOM更新
// 这里的代码会立刻执行
```

2. 结合async/await使用

```js
await nextTick();
// 这里的代码会在DOM更新后执行
console.log(element.offsetHeight);
```

> `await`关键字是ES2017引入的，用于暂停异步函数的执行，并等待Promise的解决或拒绝，然后恢复异步函数的执行并返回解析的值。
>
> `await`关键字的工作原理基于JavaScript的事件循环和Promise。当你在异步函数中使用`await`关键字时，JavaScript会将该函数的剩余部分包装成一个回调函数，并将其添加到微任务队列中。然后，JavaScript会退出当前的异步函数，继续执行其他的同步代码。
>
> 当Promise解决或拒绝时，JavaScript会将对应的回调函数添加到微任务队列中。当事件循环到达微任务队列时，它会执行队列中的回调函数。
>
> 如果`await`后面的Promise解决，那么`await`表达式的结果就是Promise解决的值。如果Promise拒绝，那么`await`表达式会抛出一个错误，你可以使用`try/catch`语句来捕获这个错误。
>
> 需要注意的是，`await`关键字只能在`async`函数中使用。`async`函数是ES2017引入的，它是一种可以包含`await`表达式的函数。`async`函数总是返回一个Promise，这使得你可以使用`await`关键字来等待`async`函数的结果。











## 第三周

### 异步组件

今天复习了异步组件的作用（看了这篇文章[如何优雅地使用Vue3的异步组件 - 掘金 (juejin.cn)](https://juejin.cn/post/7108593780638351397)），在当前公司项目测试了一下，发现根组件的创建/挂载还是优先于子组件的，给我整蒙了？？(文章里说子组件是先于父组件加载的)

**敲黑板！！！**

在Vue中，**加载**与**挂载**是两个不同的概念！！！

**"加载"**通常指的是 JavaScript 模块或者组件的加载过程，这个过程发生在浏览器解析和执行 JavaScript 代码时。当你使用 `import` 语句导入一个模块或者组件时，浏览器会加载这个模块或者组件的代码。如果你使用异步组件，那么组件的代码会在实际需要渲染这个组件时才加载。

**"挂载"**则是 Vue 中的一个概念，指的是 Vue 将组件渲染为真实 DOM 并插入到页面中的过程。在组件的生命周期中，"挂载"发生在 `beforeMount` 和 `mounted` 钩子函数之间。当组件被挂载后，你可以在页面中看到这个组件的渲染结果。

也就是说，一个组件要**先加载，再挂载**，那么前面文章里说的（子组件先于父组件**加载**是正确的），而我在代码里看到的是组件被挂载的顺序（**父组件永远优先于子组件被挂载**，这是Vue 的生命周期钩子的执行顺序决定的）

那么回到一开始的问题，异步组件的**意义**是什么？？？

异步组件的主要目的是为了代码分割和懒加载，而不是改变组件的加载顺序。当你的应用有很多组件，或者某些组件非常大时，你可能不希望一开始就加载所有的组件。这时，你可以使用异步组件来**按需加载**组件，从而提高应用的加载速度。

当你使用异步组件时，Vue 会在组件实际需要渲染时才加载它。但是，这并不会改变父组件和子组件的创建和挂载顺序。即使子组件是异步的，父组件的创建和挂载仍然会在子组件之前。





### 异常的理解

想到之前组长说我使用async/await去进行发请求但是没有进行异常的捕获，说到"异常"我总是习惯性的不去捕获和处理，这里重新复习一下异常的概念

首先要明白异常对我们执行代码有什么影响（敲黑板）！！！

**如果我们对异常不管不顾的话，那么当执行到出现异常的时候，程序可能会立即停止**

因此，平时对异常的处理是必要的，如下这个例子：

`try...catch` 语句在 JavaScript 中用于捕获和处理异常。当你的代码可能会抛出异常时，你可以将它放在 `try` 块中。如果 `try` 块中的代码抛出了异常，那么控制流会立即转到相应的 `catch` 块，你可以在 `catch` 块中处理这个异常。

让我们看一个例子

![71098636971](bug记录.assets/1710986369718.png)

这个例子就可以看出我们在没有进行异常处理时导致的后续代码无法正常执行

> 其他的异常捕获方法：
>
> 利用promise的.catch或者是.then的第二个参数



### 事件监听器的销毁

今天改了一个bug，原先的需求是使用promise对用户上传图片进行管理，然后如果用户点击上传图片但是没有选择图片进行上传，那么则开启用户对window的focus事件监听，对promise延时进行reject即可

出现的bug则是用户在成功上传一次图片之后，之后每次点击添加图片会出现prmise直接被延时reject了

最后调试发现是我们没有在成功上传图片/上传图片失败后对window的focus事件进行移除，导致用户不论成功/失败一次上传图片后window的focus事件一直存在，那么再次点击添加图片按钮则会导致直接触发延时reject，那么如果上传图片的时间小于设置的延时时间的话，则上传成功，反之上传失败

解决办法：在promise被reject/accept之后都要移除window的focus

教训就是添加window事件后记得移除！！！！（~~虽然不是我写的~~





### 事件监听器immidate带来的问题

需求是给一个子组件的双向绑定字段赋予初始值，而初始值由父组件传入后直接给到子组件中双向绑定的那个变量即可(无需监听器)，然后就发现死活的给不上，子组件也能够接受到传入的值

最后发现是事件监听immediate导致的数据覆盖，这个监听器是用于监听外部传入的modelValue并传给子组件的双向绑定变量的，但是在父组件一开始即使并没有传值的情况下，使用了immediate还是导致子组件的双向绑定变量被赋予了一个初始值空数组（这是因为defineProps里对modelValue的定义是默认值为空数组）





tips显示



tab-select



域名修改





### 路由arco







