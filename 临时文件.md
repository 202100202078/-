### 文件分隔

至此我们已经完成了整个demo登录应用，但是在实际开发中，像这样的多个路由处理的逻辑我们需要进行分开处理，便于管理

例子：

1.添加三个js文件，名称分别为login、home、logout。

2.login.js文件，添加如下内容：

```js
module.exports = function ( app ) {
    app.get('/login',function(req,res){
        res.render('login');
    });
 
    app.post('/login',function(req,res){
        var user={
            username:'admin',
            password:'admin'
        }
        if(req.body.username==user.username&&req.body.password==user.password){
            req.session.user = user;
            res.send(200);
        }else{
            req.session.error = "用户名或密码不正确"
            res.send( 404 );
        }
    });
}
```

3.home.js文件，添加如下内容：

```js
module.exports = function ( app ) {
    app.get('/home',function(req,res){
        if(req.session.user){
            res.render('home');
        }else{
            req.session.error = "请先登录"
            res.redirect('login');
        }
    });
}
```

4.logout.js文件，添加如下内容：

```js
module.exports = function ( app ) {
    app.get('/logout', function(req, res){
        req.session.user = null;
        req.session.error = null;
        res.redirect('index');
    });
}
```

然后我们原先在一个文件里与上述路由相关的操作就可以删除啦，只需引入这些文件即可

```js
require('./login')(app);
require('./home')(app);
require('./logout')(app);
```





# nodejs session应用

这里的内容是基于nodejs框架express进行介绍

## cookie与session

### 什么是cookie

在web应用中，多个请求之间*共享“用户会话”*是非常必要的。但HTTP1.0协议是无状态的。那这时Cookie就出现了。那Cookie又是如何处理的呢？

**Cookie的处理**：

- 服务端向客户端*发送Cookie*
- 客户端的浏览器把*Cookie保存*
- 然后在每次请求浏览器都会将Cookie发送到服务端

在HTML文档被发送之前，Web服务器通过传送HTTP 包头中的*Set-Cookie* 消息把一个cookie 发送到用户的浏览器中，如下示例：

```js
Set-Cookie: name=value; Path=/; expires=Wednesday, 09-Nov-99 23:12:40 GMT;
```

其中比较重要的属性：

- **name=value**：键值对，可以设置要保存的 *Key/Value*，注意这里的 name 不能和其他属性项的名字一样
- **Expires**： 过期时间（秒），在设置的某个时间点后该 Cookie 就会失效，如 expires=Wednesday, 09-Nov-99 23:12:40 GMT
- **maxAge**： 最大失效时间（毫秒），设置在多少后失效
- **secure**： 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效
- **Path**： 表示 cookie 影响到的路，如 path=/。如果路径不能匹配时，浏览器则不发送这个Cookie
- **httpOnly**： 是微软对COOKIE做的扩展。如果在COOKIE中设置了“httpOnly”属性，则通过程序（JS脚本、applet等）将无法读取到COOKIE信息，防止XSS攻击产生



### nodejs中的cookie

在nodejs中，服务端如何向客户端发送cookie呢，有如下两个方案：

- 使用**response.writeHead**，代码如下：

```js
//设置过期时间为一分钟
var today = new Date();
var time = today.getTime() + 60*1000;
var time2 = new Date(time);
var timeObj = time2.toGMTString();
response.writeHead({
   'Set-Cookie':'myCookie="type=ninja", "language=javascript";path="/";Expires='+timeObj+';httpOnly=true'
});
```

缺点：使用response.writeHead只能发送一次头部，即只能调用一次，且不能与response.render共存，否则会报错。



- 使用**response.cookie**，代码如下：

```js
语法: response.cookie('cookieName', 'name=value[name=value...]',[options]);

response.cookie('haha', 'name1=value1&name2=value2', {maxAge:10*1000, path:'/', httpOnly:true});
```

> `response.cookie`用于发送cookie给客户端，但是在服务端要访问客户端发送的cookie的话使用`request.cookies`





### express中的cookie

express 在 4.x 版本之后，管理session和cookies等许多模块都不再直接包含在express中， `而是需要单独下载安装相应模块。

```js
cookieParser安装：$ npm install cookie-parser
```

例子：

```js
//Welcome learning
var express      = require('express');
var cookieParser = require('cookie-parser');
 
var app = express();
app.use(cookieParser());
 
app.get('/', function (req, res) {
    // 如果请求中的 cookie 存在 isVisit, 则输出 cookie
    // 否则，设置 cookie 字段 isVisit, 并设置过期时间为1分钟
    if (req.cookies.isVisit) {
        console.log(req.cookies);
        res.send("再次欢迎访问");
    } else {
        res.cookie('isVisit', 1, {maxAge: 60 * 1000});
        res.send("欢迎第一次访问");
    }
});
app.listen(80);
```



### 什么是session

*session*是另一种记录客户状态的机制，不同的是**Cookie保存在客户端浏览器中**，而**session*保存在服务器*上**。

客户端浏览器访问服务器的时候，服务器把*客户端信息以某种形式记录在服务器*上，这就是session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。

如果说Cookie机制是通过检查客户身上的*“通行证”*来确定客户身份的话，那么session机制就是通过检查服务器上的*“客户明细表”*来确认客户身份。

session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。

**两者的区别：**

- cookie数据存放在客户的**浏览器**上，session数据放在**服务器**上。
- cookie不是很**安全**，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。
- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的**性能** 考虑到减轻服务器性能方面，应当使用COOKIE。
- 单个cookie保存的数据不能超过**4K**，很多浏览器都限制一个站点最多保存20个cookie。
- 所以**建议**：`将登陆信息等重要信息存放为session、其他信息如果需要保留，可以放在cookie中`



### session的简单应用

跟cookie一样都需要单独的安装和引用模块， 安装模块：`$sudo npm install express-session` 主要的方法就是 session(options)，其中 options 中包含可选参数，主要有：

- **name**: 保存 session 的字段名称，默认为 connect.sid 。
- **store**: session 的存储方式，默认存放在内存中，也可以使用 redis，mongodb 等。express 生态中都有相应模块的支持。
- **secret**: 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改。
- **cookie**: 设置存放 session id 的 cookie 的相关选项，默认为 (default: { path: '/', httpOnly: true, secure: false, maxAge: null })
- **genid**: 产生一个新的 session_id 时，所使用的函数， 默认使用 uid2 这个 npm 包。
- **rolling**: 每个请求都重新设置一个 cookie，默认为 false。
- **resave**: 即使 session 没有被修改，也保存 session 值，默认为 true。

```js
const express = require('express')
const session = require('express-session')
const app = express()

app.use(session({
	secret: 'secret',
    resave: true,
  	saveUninitialized:false,
	cookie: {maxAge:60*1000*30},
}))

app.get('/',function(req,res) {
  	console.log(req.session)
	if(req.session.sign) {
    	console.log(req.session)
		res.send('welecome <strong>' + req.session.name + '</strong>, 欢迎你再次登录');
    } else {
		req.session.sign = true
        req.session.name = 'zwf'
        res.send('欢迎首次登录')
    }
})

app.listen(80)
// 中间件是 express-session，它的作用是为 Express 应用添加会话（session）支持。当一个请求到来时，express-session 中间件会首先处理这个请求，它会查看请求中是否包含 session ID，如果包含，就从 session store 中获取对应的 session，如果不包含，就创建一个新的 session。然后，它会将这个 session 添加到 req 对象上，这样后续的中间件和路由处理器就可以通过 req.session 访问到这个 session。
```

> 理解：
>
> 为什么session也使用到了cookie呢？？？
>
> 实际上，session 是通过 cookie 来实现的。当用户第一次访问服务器时，服务器会创建一个 session，并将 session 的唯一标识符存储在 cookie 中，然后将 cookie 发送给客户端。当客户端再次访问服务器时，它会将 cookie 一起发送过来，服务器通过 cookie 中的 session 标识符找到对应的 session，从而实现跨请求的状态保持。





## 数据库存储session

前面我们的session的简单应用中，session只是存储在内存中的，那么只要进程退出了，session数据就会丢失，因此我们需要`将session数据持久化存储`

### 存储到mongoDB数据库

在使用mongodb存储时首先要加载一个模块：`*connect-mongo*`

安装命令：`npm install connect-mongo`

```js
// 代码根据包版本的不同可能有所不同
const session = require('express-session')
const MongoStore = require('connect-mongo/es5')(session)
const mongoose = require('mongoose')
const express = require('express')
const app = express()

// 连接数据库
mongoose.connect('mongodb://127.0.0.1:27017/hubwiz')

mongoose.connection.on('open', function () {
  console.log('数据库连接成功~');
})

app.use(session({
  secret: "what do you want to do?", //secret的值建议使用128个随机字符串
  cookie: { maxAge: 60 * 1000 * 60 * 24 * 14 }, //过期时间14天
  resave: true, // 即使 session 没有被修改，也保存 session 值，默认为 true
  saveUninitialized: true,
  store: new MongoStore({
    mongooseConnection: mongoose.connection //使用已有的数据库连接
  })
}));

app.listen(80);
```





### 存储到Redis数据库

Redis是一个非常适合用于Session管理的数据库。第一，它的结构简单，key-value的形式非常符合SessionID-UserID的存储；第二，读写速度非常快；第三，自身支持数据自动过期和清除；第四，语法、部署非常简单。基于以上原因，很多Session管理都是基于Redis实现的。

Express已经将Session管理的整个实现过程简化到仅仅几行代码的配置的地步了，你完全不用理解整个session产生、存储、返回、过期、再颁发的结构，使用Express和Redis实现Session管理，只要两个中间件就足够了：

- `express-session`
- `connect-redis`

**参数**

- **client** 你可以复用现有的redis客户端对象， 由 redis.createClient() 创建
- **host** Redis服务器名
- **port** Redis服务器端口
- **socket** Redis服务器的unix_socket

**可选参数**

- **ttl** Redis session TTL 过期时间 （秒）
- **disableTTL** 禁用设置的 TTL
- **db** 使用第几个数据库
- **pass** Redis数据库的密码
- **prefix** 数据表前辍即schema, 默认为 "sess:"

```js
var express = require('express');
var session = require('express-session');
var RedisStore = require('connect-redis')(session);
 
var app = express();
var options = {
    "host": "127.0.0.1",
    "port": "6379",
    "ttl": 60 * 60 * 24 * 30,   //session的有效期为30天(秒)
};
 
// req在经过session中间件的时候就会自动完成session的有效性验证、延期/重新颁发、以及对session中数据的获取了。
app.use(session({
    store: new RedisStore(options),
    secret: 'express is powerful'
}));
 
app.listen(80);
```





# Mongoose

Mongoose是基于node-mongodb-native开发的MongoDB nodejs驱动，可以在异步的环境下执行。同时它也是一个为nodejs而生的一个**对象模型库**,并且封装了MongoDB的一些常用操作方法，来用于对文档的处理。

## Mongoose基础介绍

### 认识Mongoose

介绍Mongoose之前，我们先简单了解一下**MongoDB**

MongoDB是一个开源的**NoSQL**数据库(NoSQL即非关系型数据库)，相比MySQL那样的关系型数据库，它更显得轻巧、灵活，非常适合在数据规模很大、事务性不强的场合下使用。同时它也是一个对象数据库，没有表、行等概念，也没有固定的模式和结构，所有的数据以文档的形式存储(文档，就是一个关联数组式的对象，它的内部由属性组成，一个属性对应的值可能是一个数、字符串、日期、数组，甚至是一个嵌套的文档。)，数据格式就是JSON。

而**Mongoose**是什么？

Mongoose是MongoDB的一个对象模型工具，是基于node-mongodb-native开发的MongoDB nodejs驱动，可以在异步的环境下执行。同时它也是针对MongoDB操作的一个**对象模型库**，**封装了MongoDB对文档的的一些增删改查等常用方法**，**让NodeJS操作Mongodb数据库变得更加灵活简单。**



### 使用Mongoose

安装mongoose：

```js
npm install mongoose
```

引用mongoose：

```js
var mongoose = require("mongoose");
```

使用"mongoose"连接数据库：

```js
var db = mongoose.connect("mongodb://user:pass@localhost:port/database");
```

执行下面代码检查默认数据库test，是否可以正常连接成功?

```js
var mongoose = require("mongoose");
var db = mongoose.connect("mongodb://127.0.0.1:27017/test");
db.connection.on("error", function (error) {
    console.log("数据库连接失败：" + error);
});
db.connection.on("open", function () {
    console.log("------数据库连接成功！------");
    console.log(db)
});
```

我们打印db变量可以看到一些json数据

```json
{ connections: 
   [ { base: [Circular],
       collections: {},
       models: {},
       config: [Object],
       replica: false,
       hosts: null,
       host: '127.0.0.1',
       port: 27017,
       user: undefined,
       pass: undefined,
       name: 'test',
       options: [Object],
       otherDbs: [],
       _readyState: 1,
       _closeCalled: false,
       _hasOpened: true,
       _listening: true,
       _events: [Object],
       db: [Object] } ],
  plugins: [],
  models: {},
  modelSchemas: {},
  options: { pluralization: true 
  } 
}
```



### 了解集合

MongoDB —— 是一个对象数据库，没有表、行等概念，也没有固定的模式和结构，所有的数据以**Document**(以下简称文档)的形式存储(Document，就是一个**关联数组式的对象**，它的内部由属性组成，一个属性对应的值可能是一个数、字符串、日期、数组，甚至是一个嵌套的文档。)

**在MongoDB中，多个Document可以组成Collection(以下简称集合)，多个集合又可以组成数据库。**

- **文档** —— 是MongoDB的核心概念，是键值对的一个有序集，在JavaScript里文档被表示成对象。同时它也是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的**行**，但更具表现力。
- **集合** —— 由一组文档组成，如果将MongoDB中的一个文档比喻成关系型数据库中的一行，那么一个集合就相当于一张**表**。



### 三个概念

要想使用Mongoose操作数据库，先需要了解Schema(数据属性模型)、Model、Entity

#### Schema

- Schema —— 一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。

理解：就是使用`Schema`定义表结构

　　那如何去定义一个Schema呢，请看示例：

```js
var mongoose = require("mongoose");
var TestSchema = new mongoose.Schema({
    name : { type:String },//属性name,类型为String
    age  : { type:Number, default:0 },//属性age,类型为Number,默认为0
    time : { type:Date, default:Date.now },
    email: { type:String,default:''}
});
```

基本属性类型有：字符串、日期型、数值型、布尔型(Boolean)、null、数组、内嵌文档等



#### Model

- Model —— 由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为，类似于管理数据库属性、行为的类。

　　如何通过Schema来创建Model呢，如下示例：

```js
var db = mongoose.connect("mongodb://127.0.0.1:27017/test");
// 创建Model
var TestModel = db.model("test1", TestSchema);
```

test1：数据库中的集合名称,当我们对其添加数据时如果test1已经存在，则会保存到其目录下，如果未存在，则会创建test1集合，然后再保存数据。



#### Entity

+ Entity —— 由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性。

　　使用Model创建Entity，如下示例：

```js
// 这里的TestModel是我们创建的model名
var TestEntity = new TestModel({
       name : "Lenka",
       age  : 36,
       email: "lenka@qq.com"
});
console.log(TestEntity.name); // Lenka
console.log(TestEntity.age); // 36
```

　　创建成功之后，Schema属性就变成了Model和Entity的公共属性了。



### 创建集合

```js
var mongoose = require("mongoose");
var db = mongoose.connect("mongodb://127.0.0.1:27017/test");
// 创建表结构
var TestSchema = new mongoose.Schema({
    name : { type:String },
    age  : { type:Number, default:0 },
    email: { type:String },
    time : { type:Date, default:Date.now }
});
// 创建表
var TestModel = db.model("test1", TestSchema );
// 数据定义
var TestEntity = new TestModel({
    name : "zwf",
    age  : 21,
    email: "zwf@qq.com"
});
// 添加数据
TestEntity.save(function(error,doc){
  if(error){
     console.log("error :" + error);
  }else{
     console.log(doc);
  }
});
```





## Mongoose增删改查

### 查询

查询分很多种类型，如条件查询，过滤查询等等，今天我们只学习最基本的find查询，在后面的学习中，我们会专门针对查询做详细的介绍，好，我们就先来学习使用find查询。

```js
obj.find(查询条件,callback);

Model.find({},function(error,docs){
   //若没有向find传递参数，默认的是显示所有文档
});
 
Model.find({ "age": 28 }, function (error, docs) {
  if(error){
    console.log("error :" + error);
  }else{
    console.log(docs); //docs: age为28的所有文档
  }
}); 
```





### Model保存方法

　　Model提供了一个create方法来**向表中添加一条数据**。下面我们来看一下示例：

```js
Model.create(文档数据, callback))

Model.create({ name:"model_create", age:26}, function(error,doc){
    if(error) {
        console.log(error);
    } else {
        console.log(doc);
    }
});
```





### entity保存方法

即使用entity也可以为表添加一条数据

```js
Entity.save(文档数据, callback))

var Entity = new Model({name:"entity_save",age: 27});
 
Entity.save(function(error,doc) {
    if(error) {
        console.log(error);
    } else {
        console.log(doc);
    }
});
```





### 数据更新

```js
obj.update(查询条件,更新对象,callback);

var conditions = {name : 'test_update'};
 
var update = {$set : { age : 16 }};
 
TestModel.update(conditions, update, function(error){
    if(error) {
        console.log(error);
    } else {
        console.log('Update success!');
    }
});
```



### 删除数据

```js
obj.remove(查询条件,callback);

var conditions = { name: 'tom' };
 
TestModel.remove(conditions, function(error){
    if(error) {
        console.log(error);
    } else {
        console.log('Delete success!');
    }
});
```





## Mongoose简单查询

除了前面我们学习的`find`查询之外，Mongoose模型还提供了`findOne`、`findById`方法进行文档查询

### find过滤查询

本质上就是控制你要显示哪些字段

```js
find(Conditions,field,callback);
//field省略或为Null，则返回所有属性

// 如果在MySQL中则这样写select name,age from Model

//返回只包含一个键值name、age的所有记录
Model.find({},{name:1, age:1, _id:0}，function(err,docs){
   //docs 查询结果集
})
//说明：我们只需要把显示的属性设置为大于零的数就可以，当然1是最好理解的
```



### findOne

与find相同，但只返回单个文档，也就说当查询到即一个符合条件的数据时，将停止继续查询，并返回查询结果

```js
单条数据 findOne(Conditions,callback);

TestModel.findOne({age:27},function(err,docs){
   console.log(docs);
});
```



### findById

与findOne相同，但它只接收文档的_id作为参数，返回单个文档

```js
单条数据 findById(_id, callback);

TestModel.findById('obj._id', function (err, doc){
 //doc 查询结果文档
});    

TestModel.findById('66090dc315fc182b0062e962',function(err,docs){
   console.log(docs);
});	
```



## Mongoose高级查询

　"$lt"(小于)，"$lte"(小于等于),"$gt"(大于)，"$gte"(大于等于)，"$ne"(不等于)，"$in"(可单值和多个值的匹配)，"$or"(查询多个键值的任意给定值)，"$exists"(表示是否存在的意思)"$all"



### 大于小于

可以使用$gt(>)、$lt(<)、$lte(<=)、$gte(>=)操作符进行排除性的查询，如下示例：

```js
Model.find({"age":{"$gt":18}},function(error,docs){
   //查询所有nage大于18的数据
});
 
Model.find({"age":{"$lt":60}},function(error,docs){
   //查询所有nage小于60的数据
});
 
Model.find({"age":{"$gt":18,"$lt":60}},function(error,docs){
   //查询所有nage大于18小于60的数据
});
```



### 不等于

$ne(!=)操作符的含义相当于不等于、不包含，查询时我们可通过它进行条件判定，具体使用方法如下：

```js
Model.find({ age:{ $ne:24}},function(error,docs){
    //查询age不等于24的所有数据
});
 
Model.find({name:{$ne:"tom"},age:{$gte:18}},function(error,docs){
  //查询name不等于tom、age>=18的所有数据
});
```

$ne可以匹配单个值，也可以匹配不同类型的值。



### 等于/包含

和$ne操作符相反，$in相当于包含、等于，查询时查找包含于指定字段条件的数据。具体使用方法如下：

```js
Model.find({ age:{ $in: 20}},function(error,docs){
   //查询age等于20的所有数据
});
 
Model.find({ age:{$in:[20,30]}},function(error,docs){
  //可以把多个值组织成一个数组
}); 
```



### 或

$or操作符，可以查询多个键值的任意给定值，只要满足其中一个就可返回，用于存在多个条件判定的情况下使用，如下示例：

````js
Model.find({"$or":[{"name":"yaya"},{"age":28}]},function(error,docs){
  //查询name为yaya或age为28的全部文档
});
````





### 存在

$exists操作符，可用于判断某些关键字段是否存在来进行条件查询。如下示例：

```js
Model.find({name: {$exists: true}},function(error,docs){
  //查询所有存在name属性的文档
});
Model.find({telephone: {$exists: false}},function(error,docs){
  //查询所有不存在telephone属性的文档
});
```





## Mongoose游标

数据库使用游标返回find的执行结果。客户端对游标的实现通常能够对最终结果进行有效的控制。可以限制结果的数量，略过部分结果，根据任意键按任意顺序的组合对结果进行各种排序，或者是执行其他一些强的操作

最常用的查询选项就是限制返回结果的数量(limit函数)、忽略一点数量的结果(skip函数)以及排序(sort函数)。所有这些选项一点要在查询被发送到服务器之前指定。



### 限制返回数量

在查询操作中，有时数据量会很大，这时我们就需要对返回结果的数量进行限制，那么我们就可以使用limit函数，通过它来限制结果数量。

```js
限制数量：find(Conditions,fields,options,callback);

Model.find({},null,{limit:20},function(err,docs){
    console.log(docs);
});

如果匹配的结果不到20个，则返回匹配数量的结果，也就是说limit函数指定的是上限而非下限。
```



### skip跳过结果数量

　skip函数和limit类似，都是对返回结果数量进行操作，不同的是skip函数的功能是略过指定数量的匹配结果，返回余下的查询结果。如下示例：

```js
跳过数量：find(Conditions,fields,options,callback);

Model.find({},null,{skip:4},function(err,docs){
    console.log(docs);
});
//如果查询结果数量中少于4个的话，则不会返回任何结果。
```



### sort排序

sort函数可以将查询结果数据进行排序操作，该函数的参数是一个或多个键/值对，键代表要排序的键名，值代表排序的方向，1是升序，-1是降序。

```js
结果排序：find(Conditions,fields,options,callback);

Model.find({},null,{sort:{age:-1}},function(err,docs){
  //查询所有数据，并按照age降序顺序返回数据docs
});
```





## Mongoose属性方法

### ObjectId类型

存储在mongodb集合中的每个文档（document）都有一个默认的主键_id，这个主键名称是固定的，它可以是mongodb支持的任何数据类型，默认是ObjectId。该类型的值由系统自己生成，从某种意义上几乎不会重复，生成过程比较复杂，有兴趣的朋友可以查看源码。

使用过MySQL等关系型数据库的友友们都知道，主键都是设置成自增的。但在分布式环境下，这种方法就不可行了，会产生冲突。为此，MongoDB采用了一个称之为ObjectId的类型来做主键。ObjectId是一个12字节的 BSON 类型字符串。按照字节顺序，一次代表：

- 4字节：UNIX时间戳
- 3字节：表示运行MongoDB的机器
- 2字节：表示生成此_id的进程
- 3字节：由一个随机数开始的计数器生成的值

```js
var mongoose = require('mongoose');var tSchema = new mongoose.Schema({}); //默认_id:ObjectId类型
```

　　每一个文档都有一个特殊的键“_id”，这个键在文档所属的集合中是唯一的。



### 添加属性

　　前面我们已经讲述了如何定义一个Schema并赋予某些属性值,那能不能先定义后添加属性呢，答案是可以的，如下所示：

```js
var mongoose = require('mongoose');
var TempSchema = new mongoose.Schema;
TempSchema.add({ name: 'String', email: 'String', age: 'Number' });
```



### 实例方法

　　有的时候，我们创造的Schema不仅要为后面的Model和Entity提供公共的属性，还要提供公共的方法.那怎么在Schema下创建一个实例方法呢，请看示例：

```js
var mongoose = require('mongoose');
var saySchema = new mongoose.Schema({name : String});
saySchema.method('say', function () {
  console.log('Trouble Is A Friend');
})
var say = mongoose.model('say', saySchema);
var lenka = new say();
lenka.say(); //Trouble Is A Friend
```



### 静态方法

怎么为Schema创建静态方法。如下示例：

```js
var mongoose = require("mongoose");
var db = mongoose.connect("mongodb://127.0.0.1:27017/test");
var TestSchema = new mongoose.Schema({
    name : { type:String },
    age  : { type:Number, default:0 },
    email: { type:String, default:"" },
    time : { type:Date, default:Date.now }
});
 
TestSchema.static('findByName', function (name, callback) {
    return this.find({ name: name }, callback);
});
 
var TestModel = db.model("test1", TestSchema );
TestModel.findByName('tom', function (err, docs) {
 //docs所有名字叫tom的文档结果集
});
```





### 追加方法

关于Schema的如何定义前面我们已经讲述过了，有时场景的需要，我们甚至可以为Schema模型追加方法。

　　为Schema模型追加speak方法，如下示例：

```js
var mongoose = require("mongoose");
var db = mongoose.connect("mongodb://127.0.0.1:27017/test");
var TestSchema = new mongoose.Schema({
    name : { type:String },
    age  : { type:Number, default:0 },
    email: { type:String, default:"" },
    time : { type:Date, default:Date.now }
});
 
TestSchema.methods.speak = function(){
  console.log('我的名字叫'+this.name);
}
 
var TestModel = db.model('test1',TestSchema);
var TestEntity = new TestModel({name:'Lenka'});
TestEntity.speak();//我的名字叫Lenka
```

