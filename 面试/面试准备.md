# 面试考点导图

![img](https://uploadfiles.nowcoder.com/files/20220301/4107856_1646121184706/TDEVWASTBug7plrP1G2qJw.png)



# 自我记录

- typeof 与 instanceof的区别

[typeof 与 instanceof 有哪些区别 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/653623802#:~:text=typeof%E7%94%A8%E4%BA%8E%E7%A1%AE%E5%AE%9A%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%80%8Cinstanceof%E7%94%A8%E4%BA%8E%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E6%9F%90%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E4%BE%8B%E3%80%82,%E8%99%BD%E7%84%B6typeof%E5%8F%AF%E4%BB%A5%E6%A3%80%E6%9F%A5%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BD%86%E6%97%A0%E6%B3%95%E6%A3%80%E6%9F%A5%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E3%80%82%20%E8%80%8Cinstanceof%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF%E9%93%BE%E4%B8%8A%E8%BF%9B%E8%A1%8C%E6%A3%80%E6%9F%A5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%98%8E%E7%A1%AE%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%88%96%E5%85%B6%E5%AD%90%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E3%80%82)

- 实现深拷贝的方式

[深拷贝的实现方式（超全） - 掘金 (juejin.cn)](https://juejin.cn/post/7013603488315736072#heading-6)

- 判断一个变量是否为数组

[JavaScript 判断数组的方法总结，哪种最靠谱？ - 掘金 (juejin.cn)](https://juejin.cn/post/7064713519672852511?searchId=20231111121427F3105C9F2DAA9EAEC78F)

- 判断对象是否为空

[JavaScript判断空对象的5+1种方式 - 掘金 (juejin.cn)](https://juejin.cn/post/7010032895414763557?searchId=202311111216582D54E2DD4D0128B348D2)

- Vue2中给对象添加新属性界面不刷新?

[面试官：Vue中给对象添加新属性界面不刷新?-CSDN博客](https://blog.csdn.net/weixin_44475093/article/details/110944565)











# 前端基础

## HTML

### **html标签的类型及作用**

**参考答案：**

!DOCTYPE 标签：

- 它是指示 web 浏览器 文档所使用的 HTML 规范

head：

- 是所有头部元素的容器, 绝大多数头部标签的内容不会显示给读者
- 该标签下所包含的部分可加入的标签有 style、title、link

body :

- 用于定义文档的主体, 包含了文档的所有内容
- 该标签支持 html 的全局属性和事件属性.






### **HTML5新特性**

[HTML5新特性 - 掘金 (juejin.cn)](https://juejin.cn/post/7212857649938858040)

**参考答案：**

- 新增选择器 document.querySelector、document.querySelectorAll


- 语义化标签 article、footer、header、nav、section
- 本地存储 localStorage 和 sessionStorage
- 增强表单控件 calendar、date、time、email、url、search
- 媒体播放的 video 和 audio
- 绘画 canvas
- 拖拽释放(Drag and drop) API

H5移除的元素：

- 纯表现的元素：basefont、big、center、font、s、strike、tt、u
- 对可用性产生负面影响的元素：frame、frameset、noframes







### **伪类和伪元素**

**参考答案：**

**伪类**：用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的。

例如：当用户悬停在指定元素时，可以通过:hover来描述这个元素的状态，虽然它和一般css相似，可以为 已有元素添加样式，但是它只有处于DOM树无法描述的状态下才能为元素添加样式，所以称为伪类。

**伪元素**：用于创建一些不在DOM树中的元素，并为其添加样式。

例如，我们可以通过:before来在一个元素之前添加一些文本，并为这些文本添加样式，虽然用户可以看见 这些文本，但是它实际上并不在DOM文档中。





### **HTML5语义化与常用标签**

**参考答案：**

在HTML5出来之前，我们习惯于用div来表示页面的章节或者不同模块，但是div本身是没有语义的。但是现在，HTML5中加入了一些语义化标签，来更清晰的表达文档结构。

标签：

![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646121492395/44B73F2E744FF268279D16601DB2CBC8)

> <title>      <!--：页面主体内容。-->
> <hn>         <!--：h1~h6，分级标题，<h1> 与 <title> 协调有利于搜索引擎优化。-->
> <ul>         <!--：无序列表。-->
> <li>         <!--：有序列表。-->
> <header>     <!--：页眉通常包括网站标志、主导航、全站链接以及搜索框。-->
> <nav>         <!--：标记导航，仅对文档中重要的链接群使用。-->
> <main>         <!--：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。-->
> <article>    <!--：定义外部的内容，其中的内容独立于文档的其余部分。-->
> <section>    <!--：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。-->
> <aside>         <!--：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。-->
> <footer>     <!--：页脚，只有当父级是body时，才是整个页面的页脚。-->
> <small>      <!--：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。-->
> <strong>     <!--：和 em 标签一样，用于强调文本，但它强调的程度更强一些。-->
> <em>         <!--：将其中的文本表示为强调的内容，表现为斜体。-->
> <mark>       <!--：使用黄色突出显示部分文本。-->
> <figure>     <!--：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。-->
> <figcaption><!--：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。-->
> <cite>       <!--：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。-->
> <blockquoto><!--：定义块引用，块引用拥有它们自己的空间。-->
> <q>          <!--：短的引述（跨浏览器问题，尽量避免使用）。-->
> <time>       <!--：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。-->
> <abbr>       <!--：简称或缩写。-->
> <dfn>       <!--：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。-->
> <address>    <!--：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。-->
> <del>        <!--：移除的内容。-->
> <ins>        <!--：添加的内容。-->
> <code>       <!--：标记代码。-->
> <meter>      <!--：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）-->
> <progress>    <!--：定义运行中的进度（进程）。-->
>
> 语义化优点：
>
> - 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。
> - 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。
> - 方便屏幕阅读器解析，如盲人阅读器根据语义渲染网页
> - 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。





### **audio 标签的api**

**参考答案：**

audio常用属性

| **属性** | **属性值** | **注释**                                                     |
| -------- | ---------- | ------------------------------------------------------------ |
| src      | url        | 播放的音乐的url地址（火狐只支持ogg的音乐，而IE9只支持MP3格式的音乐。chrome貌似全支持） |
| preload  | preload    | 预加载（在页面被加载时进行加载或者说缓冲音频），如果使用了autoplay的话那么该属性失效。 |
| loop     | loop       | 循环播放                                                     |
| controls | controls   | 是否显示默认控制条（控制按钮）                               |
| autoplay | autoplay   | 自动播放                                                     |

audio音乐格式的支持

| **音频格式** | **Chrome** | **Firefox** | **IE9** | **Opera** | **Safari** |
| ------------ | ---------- | ----------- | ------- | --------- | ---------- |
| OGG          | √          | √           | √       | ×         | ×          |
| MP3          | √          | ×           | √       | ×         | √          |
| WAV          | ×          | √           | ×       | √         | ×          |

audio属性

| 属性        | 注释                                                         |
| ----------- | ------------------------------------------------------------ |
| duration    | 获取媒体文件的总时长，以s为单位，如果无法获取，返回NaN       |
| paused      | 如果媒体文件被暂停，那么paused属性返回true，反之则返回false  |
| ended       | 如果媒体文件播放完毕返回true                                 |
| muted       | 用来获取或设置静音状态。值为boolean                          |
| volume      | 控制音量的属性值为0-1;0为音量最小，1为音量最大               |
| startTime   | 返回起始播放时间                                             |
| error       | 返回错误代码，为uull的时候为正常。否则可以通过Music.error.code来获取具体的错误代码： 1.用户终止 2.网络错误 3.解码错误 4.URL无效 |
| currentTime | 用来获取或控制当前播放的时间，单位为s。                      |
| currentSrc  | 以字符串形式返回正在播放或已加载的文件                       |

常用的控制用的函数：

| 函数             | 作用                                                 |
| ---------------- | ---------------------------------------------------- |
| load()           | 加载音频、视频软件                                   |
| play()           | 加载并播放音频、视频文件或重新播放暂停的的音频、视频 |
| pause()          | 暂停出于播放状态的音频、视频文件                     |
| canPlayType(obj) | 测试是否支持给定的Mini类型的文件                     |

常用audio的事件：

| 事件名称       | 事件作用                                           |
| -------------- | -------------------------------------------------- |
| loadstart      | 客户端开始请求数据                                 |
| progress       | 客户端正在请求数据（或者说正在缓冲）               |
| play           | play()和autoplay播放时                             |
| pause          | pause()方法促发时                                  |
| ended          | 当前播放结束                                       |
| timeupdate     | 当前播放时间发生改变的时候。播放中常用的时间处理哦 |
| canplaythrough | 歌曲已经载入完全完成                               |
| canplay        | 缓冲至目前可播放状态。                             |





## JS基础

### var let const相关

**参考答案：**

**var** ——ES5 变量声明方式

1. 作用域——var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用
2. var允许先使用再声明，且可以重复声明

**let**——ES6变量声明方式

1. 在变量未声明前直接使用会报错
2. 作用域——let为块作用域——通常let比var 范围要小
3. let禁止重复声明变量，否则会报错

**const**——ES6变量声明方式

1. const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改该常量的值
2. const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动





### 数据类型及其区别

**参考答案：**

基本数据类型：

Number，String，Boolean，null，undefined，symbol，bigint（后两个为ES6新增）

引用数据类型：

object，function（**proto** Function.prototype），array

object：普通对象，数组对象，正则对象，日期对象，Math数学函数对象。

两种数据存储方式：

基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈是存储基本类型值和执行代码的空间。

引用数据类型是存储在堆内存中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆 中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。

两种数据类型的区别：

1. 堆比栈空间大，栈比堆运行速度快。
2. 堆内存是无序存储，可以根据引用直接获取。
3. 基础数据类型比较稳定，而且相对来说占用的内存小。
4. 引用数据类型大小是动态的，而且是无限的。





### Object.assign的理解

**参考答案：**

作用：Object.assign可以实现对象的合并。

语法：Object.assign(target, ...sources)

**解析**：

1. Object.assign会将source里面的可枚举属性复制到target，如果和target的已有属性重名，则会覆盖。
2. 后续的source会覆盖前面的source的同名属性。
3. Object.assign复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题即**浅拷贝**





### constructor的理解

**参考答案：**

创建的每个函数都有一个prototype（原型）对象，这个属性是一个指针，指向一个对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（继承自构造函数的prototype），指向构造函数的原型对象。注意当将构造函数的prototype设置为等于一个以对象字面量形式创建的新对象时，constructor属性不再指向该构造函数。

![69269076344](D:\MyProject\HTMLCSSJavaScript\JavaScript\笔记\assets\1692690763447.png)![69271150138](D:\MyProject\HTMLCSSJavaScript\JavaScript\笔记\assets\1692711501388.png)





### map 和 forEach 的区别

**参考答案：**

相同点：

1. 都是循环遍历数组中的每一项
2. 每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），arr（原数组）
3. 匿名函数中的this都是指向window
4. 只能遍历数组

**不同点**：

1. **map()会分配内存空间存储新数组并返回，forEach()不会返回数据**。
2. **forEach()允许callback更改原始数组的元素。map()返回新的数组**。







### for of 可以遍历哪些对象

**参考答案：**

for..of..: 它是es6新增的一个遍历方法，但**只限于迭代器(iterator)**, 所以普通的对象用for..of遍历
是会报错的。

可迭代的对象：包括Array, Map, Set, String, TypedArray, arguments对象等等

[for...of - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of)





### js静态类型检查

**参考答案：**

**js是动态类型语言**

静态类型语言 & 动态类型语言

静态类型语言：类型检查发生在编译阶段，因此除非修复错误，否则会一直编译失败

动态类型语言：只有在程序运行了一次的时候错误才会被发现，也就是在运行时，因此即使代码中包含了会 在运行时阻止脚本正常运行的错误类型，这段代码也可以通过编译

**js静态类型检查的方法**

**Flow**是Facebook开发和发布的一个开源的静态类型检查库，它允许你逐渐地向JavaScript代码中添加类型。

**TypeScript**是一个会编译为JavaScript的超集（尽管它看起来几乎像一种新的静态类型语言）

**使用静态类型的优势**

- 可以尽早发现bug和错误
- 减少了复杂的错误处理
- 将数据和行为分离
- 减少单元测试的数量
- 提供了领域建模（domain modeling）工具
- 帮助我们消除了一整类bug
- 重构时更有信心

**使用静态类型的劣势**

- 代码冗长
- 需要花时间去掌握类型





### indexof

**参考答案：**

语法：str.indexOf(searchValue [, fromIndex])

参数：searchValue：要被查找的字符串值。

如果没有提供确切地提供字符串，[searchValue 会被强制设置为"undefined"]， 然后在当前字符串中查 找这个值。

举个例子：'undefined'.indexOf()将会返回0，因为undefined在位置0处被找到，但是'undefine'.indexOf()将会返回 -1 ，因为字符串'undefined'未被找到

fromIndex：可选

数字表示开始查找的位置。可以是任意整数，默认值为0。

如果fromIndex的值小于0，或者大于str.length，那么查找分别从0和str.length开始。（译者 注：fromIndex的值小于0，等同于为空情况；fromIndex的值大于或等于str.length，那么结果 会直接返回-1。）

举个例子，'hello world'.indexOf('o', -5)返回4，因为它是从位置0处开始查找，然后o在位置4处被找到。另一方面，'hello world'.indexOf('o', 11)（或fromIndex填入任何大于11的值） 将会返回-1，因为开始查找的位置11处，已经是这个字符串的结尾了。

返回值：

查找的字符串searchValue的**第一次**出现的索引，如果没有找到，则返回-1。

若被查找的字符串searchValue是一个空字符串，则返回fromIndex。如果fromIndex值为空，或者fromIndex值小于被查找的字符串的长度，返回值和以下的fromIndex值一样。

如果fromIndex值大于等于字符串的长度，将会直接返回字符串的长度（str.length）

特点：

1. 严格区分大小写
2. **在使用indexOf检索数组时，用‘===’去匹配，意味着会检查数据类型**





### iframe有什么优点、缺点

**参考答案：**

[HTML  标签 | 菜鸟教程 (runoob.com)](https://www.runoob.com/tags/tag-iframe.html)

优点：

1. iframe能够原封不动的把嵌入的网页展现出来。
2. 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。
3. 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。
4. 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。

缺点：

1. iframe会阻塞主页面的onload事件；
2. iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。会产生很多页面，不容易管理。
3. iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。
4. 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化（SEO）。
5. 很多的移动设备无法完全显示框架，设备兼容性差。
6. iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。







### webComponents

**参考答案：**

**Web Components** 总的来说是提供一整套完善的封装机制来把 Web 组件化这个东西标准化，每个框架实现 的组件都统一标准地进行输入输出，这样可以更好推动组件的复用

包含四个部分

1. Custom Elements


2. HTML Imports
3. HTML Templates
4. Shadow DOM

**Custom Elements**

提供一种方式让开发者可以自定义 HTML 元素，包括特定的组成，样式和行为。支持 Web Components 标准的浏览器会提供一系列 API 给开发者用于创建自定义的元素，或者扩展现有元素。

**HTML Imports**

一种在 HTMLs 中引用以及复用其他的 HTML 文档的方式。这个 Import 很漂亮，可以简单理解为我们常见 的模板中的include之类的作用

**HTML Templates**

模板

**Shadow DOM**

提供一种更好地组织页面元素的方式，来为日趋复杂的页面应用提供强大支持，避免代码间的相互影响





### dva的数据流流向是怎么样的

**参考答案：**

数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据 的时候可以通过dispatch发起一个 action，如果是同步行为会直接通过Reducers改变State，如果是 异步行为（副作用）会先触发Effects然后流向Reducers最终改变State，所以在 dva 中，数据流向非 常清晰简明，并且思路基本跟开源社区保持一致。

![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646121613938/80A2D6E5BA845BDC932EF25370C0DB0D)





### 变量提升

**参考答案：**

JavaScript是单线程语言，所以执行肯定是按顺序执行。但是并不是逐行的分析和执行，而是一段一段地分析执行，会先进行编译阶段然后才是执行阶段。在编译阶段阶段，代码真正执行前的几毫秒，会检测到所有的变量和函数声明，所有这些函数和变量声明都被添加到名为Lexical Environment的JavaScript数据结构内的内存中。所以这些变量和函数能在它们真正被声明之前使用。





### 作用域

**参考答案：**

**概念：**作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

**ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域**。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。





### Map 和 Array 有什么区别？

[Map - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)

**参考答案：**

1. 查找效率
   HashMap因为其根据hashcode的值直接算出index,所以其查找效率是随着数组长度增大而增加的。
   ArrayMap使用的是二分法查找，所以当数组长度每增加一倍时，就需要多进行一次判断，效率下降
2. 扩容数量
   HashMap初始值16个长度，每次扩容的时候，直接申请双倍的数组空间。
   ArrayMap每次扩容的时候，如果size长度大于8时申请size*1.5个长度，大于4小于8时申请8个，小于4时申 请4个。这样比较ArrayMap其实是申请了更少的内存空间，但是扩容的频率会更高。因此，如果数据量比较大的时候，还是使用HashMap更合适，因为其扩容的次数要比ArrayMap少很多。
3. 扩容效率
   HashMap每次扩容的时候重新计算每个数组成员的位置，然后放到新的位置。
   ArrayMap则是直接使用System.arraycopy，所以效率上肯定是ArrayMap更占优势。
4. 内存消耗
   以ArrayMap采用了一种独特的方式，能够重复的利用因为数据扩容而遗留下来的数组空间，方便下一个ArrayMap的使用。而HashMap没有这种设计。 由于ArrayMap之缓存了长度是4和8的时候，所以如果频繁的使用到Map，而且数据量都比较小的时候，ArrayMap无疑是相当的是节省内存的。

总结
综上所述，数据量比较小，并且需要频繁的使用Map存储数据的时候，推荐使用ArrayMap。 而数据量比较大的 时候，则推荐使用HashMap。



### Map和Object

**参考答案：**

Objects和Maps类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成Maps使用。不过Maps和Objects有一些重要的区别，在下列情况里使用Map会是更好的选择：

|          | Map                                                          | Object                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 意外的键 | Map默认情况不包含任何键。只包含显式插入的键。                | 一个Object有一个原型, 原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。**注意:** 虽然 ES5 开始可以用Object.create(null)来创建一个没有原型的对象，但是这种用法不太常见。 |
| 键的类型 | 一个Map的键可以是**任意值**，包括函数、对象或任意基本类型。  | 一个Object的键必须是一个 [String](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String) 或是[Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)。 |
| 键的顺序 | Map中的 key 是有序的。因此，当迭代的时候，一个Map对象以插入的顺序返回键值。 | 一个Object的键是无序的注意：自ECMAScript 2015规范以来，对象*确实*保留了字符串和Symbol键的创建顺序； 因此，在只有字符串键的对象上进行迭代将按插入顺序产生键。 |
| Size     | Map的键值对个数可以轻易地通过[size](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/size) 属性获取 | Object的键值对个数只能手动计算                               |
| 迭代     | Map是 [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable) 的，所以可以直接被迭代。 | 迭代一个Object需要以某种方式获取它的键然后才能迭代。         |
| 性能     | 在频繁增删键值对的场景下表现更好。                           | 在频繁添加和删除键值对的场景下未作出优化。                   |





### javascript中arguments相关的问题

**参考答案：**

**arguments**

在js中，我们在调用有参数的函数时，当往这个调用的有参函数传参时，js会把所传的参数全部存到一个叫arguments的对象里面。它是一个**类数组数据**

**由来**

Javascrip中每个函数都会有一个Arguments对象实例arguments，引用着函数的实参。它是寄生在js函数当中的，不能显式创建，arguments对象只有函数开始时才可用

**作用**

有了arguments这个对象之后，我们可以不用给函数预先设定形参了，可以动态地通过arguments为函数加入参数





### instanceOf 原理，手动实现 function isInstanceOf (child, Parent)

**参考答案**：

instanceof主要作用就是判断一个实例是否属于某种类型

```javascript
let person = function(){

}
let no = new person()
no instanceof person//true
```

instanceOf 原理

```javascript
function new_instance_of(leftVaule, rightVaule) { 
    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
    while (true) {
        if (leftVaule === null) {
            return false;    
        }
        if (leftVaule === rightProto) {
            return true;    
        } 
        leftVaule = leftVaule.__proto__ 
    }
}
```

其实 **instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。**

同时还要了解js的原型继承原理

![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646121650388/2B869BED138922220E1DC0C5C1B898EE)

我们知道每个 JavaScript 对象均有一个隐式的 proto 原型属性，而显式的原型属性是 prototype，只有 Object.prototype.proto 属性在未修改的情况下为 null 值

手动实现

```javascript
function instance_of(L, R) {//L 表示左表达式，R 表示右表达式
    var O = R.prototype;
    L = L.__proto__;
    while (true) { 
        if (L === null) 
        return false; 
        if (O === L) // 这里重点：当 O 严格等于 L 时，返回true 
        return true; 
        L = L.__proto__; 
    } 
}
// 开始测试
var a = []
var b = {}

function Foo(){}
var c = new Foo()
function child(){}
function father(){}
child.prototype = new father() 
var d = new child()

console.log(instance_of(a, Array)) // true
console.log(instance_of(b, Object)) // true
console.log(instance_of(b, Array)) // false
console.log(instance_of(a, Object)) // true
console.log(instance_of(c, Foo)) // true
console.log(instance_of(d, child)) // true
console.log(instance_of(d, father)) // true
```





### 数组去重

**参考答案：**

**1. 利用ES6 Set去重（ES6中最常用）**

```javascript
function unique (arr) {
  return Array.from(new Set(arr))
    // const set = new Set(arr)
    // return [...set]
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
 //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]
```

不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。

**2. 利用for嵌套for，然后splice去重（ES5中最常用）**

```javascript
function unique(arr){            
        for(var i=0; i<arr.length; i++){
            for(var j=i+1; j<arr.length; j++){
                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个
                    arr.splice(j,1);
                    j--;
                }
            }
        }
return arr;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
    //[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", {…}, {…}]     //NaN和{}没有去重，两个null直接消失了
```

双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。

**3. 利用indexOf去重**

```javascript
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var array = [];
    for (var i = 0; i < arr.length; i++) {
        if (array.indexOf(arr[i]) === -1) {
            array.push(arr[i])
        }
    }
    return array;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
   // [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", {…}, {…}]  //NaN、{}没有去重
```

新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。

**4. 利用sort()**

```javascript
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return;
    }
    arr = arr.sort()
    var arrry= [arr[0]];
    for (var i = 1; i < arr.length; i++) {
        if (arr[i] !== arr[i-1]) {
            arrry.push(arr[i]);
        }
    }
    return arrry;
}
     var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
// [0, 1, 15, "NaN", NaN, NaN, {…}, {…}, "a", false, null, true, "true", undefined]      //NaN、{}没有去重
```

利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。

**5. 利用includes**

```javascript
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var array =[];
    for(var i = 0; i < arr.length; i++) {
            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值
                    array.push(arr[i]);
              }
    }
    return array
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
    //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]     //{}没有去重
```

**6. 利用hasOwnProperty**

```javascript
function unique(arr) {
    var obj = {};
    return arr.filter(function(item, index, arr){
        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)
    })
}
    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}]   //所有的都去重了
```

利用hasOwnProperty 判断是否存在对象属性

**7. 利用filter**

```javascript
function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
//[1, "true", true, 15, false, undefined, null, "NaN", 0, "a", {…}, {…}]
```

**8. 利用递归去重**

```javascript
function unique(arr) {
        var array= arr;
        var len = array.length;

    array.sort(function(a,b){   //排序后更加方便去重
        return a - b;
    })

    function loop(index){
        if(index >= 1){
            if(array[index] === array[index-1]){
                array.splice(index,1);
            }
            loop(index - 1);    //递归loop，然后数组去重
        }
    }
    loop(len-1);
    return array;
}
 var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
//[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]
```

**9. 利用Map数据结构去重**

```javascript
function arrayNonRepeatfy(arr) {
  let map = new Map();
  let array = new Array();  // 数组用于返回结果
  for (let i = 0; i < arr.length; i++) {
    if(map.has(arr[i])) {  // 如果有该key值
      map.set(arr[i], true); 
    } else { 
      map.set(arr[i], false);   // 如果没有该key值
      array.push(arr[i]);
    }
  } 
  return array ;
}
 var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
//[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]
```

创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。

**10. 利用reduce+includes**

```javascript
function unique(arr){
    return arr.reduce((prev,cur) => prev.includes(cur) ? prev : [...prev,cur],[]);
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr));
// [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]
```

**11. [...new Set(arr)]**

```javascript
[...new Set(arr)] 
//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）
```



### 编码和字符集的区别

**参考答案：**

简单理解类似ASCII码中左边a对应ASCII值97就左边合起来就是字符集，这种映射就叫编码

字符集是书写系统字母与符号的集合，而字符编码则是将字符映射为一特定的字节或字节序列，是一种规则。通常特定的字符集采用特定的编码方式（即一种字符集对应一种字符编码（例如：ASCII、IOS-8859-1、GB2312、GBK，都是即表示了字符集又表示了对应的字符编码，但Unicode不是，它采用现代的模型））

> **扩展：**
>
> 字符：在计算机和电信技术中，一个字符是一个单位的字形、类字形单位或符号的基本信息。即一个字符可以是一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号等。
>
> 字符集：多个字符的集合。例如GB2312是中国国家标准的简体中文字符集，GB2312收录简化汉字（6763个）及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。
>
> 字符编码：把字符集中的字符编码为（映射）指定集合中的某一对象（例如：比特模式、自然数序列、电脉冲），以便文本在计算机中存储和通过通信网络的传递。





### null 和 undefined 的区别，如何让一个属性变为null

**参考答案：**

undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。

**解析：**

**undefined** 的字面意思就是：未定义的值 。这个值的语义是，希望**表示一个变量最原始的状态，而非人为操作的结果 。** 这种原始状态会在以下 4 种场景中出现：

1. 声明了一个变量，但没有赋值
2. 访问对象上不存在的属性
3. 函数定义了形参，但没有传递实参
4. 使用 void 对表达式求值

因此，undefined 一般都来自于某个表达式最原始的状态值，不是人为操作的结果。当然，你也可以手动给一个变量赋值 undefined，但这样做没有意义，因为一个变量不赋值就是 undefined 。

**null** 的字面意思是：空值 。这个值的语义是，希望**表示 一个对象被人为的重置为空对象，而非一个变量最原始的状态 。** 在内存里的表示就是，**栈中的变量没有指向堆中的内存对象**

![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646121680358/0B3EF648CF963F2F1CFB70DE3D6350F4)

null 有属于自己的类型 Null，而不属于Object类型，typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，**二进制的前三位为 0 会被 typeof 判断为对象类型**，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。





### 数组和伪数组的区别

**参考答案**：

1. 定义

- 数组是一个特殊对象,与常规对象的区别：
  - 当由新元素添加到列表中时，自动更新length属性
  - 设置length属性，可以截断数组
  - 从Array.protoype中继承了方法
  - 属性为'Array'
- 类数组是一个拥有length属性，并且他属性为非负整数的普通对象，类数组不能直接调用数组方法。

1. 区别
   本质：类数组是简单对象，它的原型关系与数组不同。

```javascript
// 原型关系和原始值转换
let arrayLike = {
    length: 10,
};
console.log(arrayLike instanceof Array); // false
console.log(arrayLike.__proto__.constructor === Array); // false
console.log(arrayLike.toString()); // [object Object]
console.log(arrayLike.valueOf()); // {length: 10}

let array = [];
console.log(array instanceof Array); // true
console.log(array.__proto__.constructor === Array); // true
console.log(array.toString()); // ''
console.log(array.valueOf()); // []
```

1. 类数组转换为数组

- 转换方法
  - 使用Array.from()
  - 使用Array.prototype.slice.call()
  - 使用Array.prototype.forEach()进行属性遍历并组成新的数组
- 转换须知
  - 转换后的数组长度由length属性决定。索引不连续时转换结果是连续的，会自动补位。
  - 代码示例

```javascript
let al1 = {
    length: 4,
    0: 0,
    1: 1,
    3: 3,
    4: 4,
    5: 5,
};
console.log(Array.from(al1)) // [0, 1, undefined, 3]
```

- ②仅考虑 0或正整数 的索引

```javascript
// 代码示例
let al2 = {
    length: 4,
    '-1': -1,
    '0': 0,
    a: 'a',
    1: 1
};
console.log(Array.from(al2)); // [0, 1, undefined, undefined]
```

- ③使用slice转换产生稀疏数组

```javascript
// 代码示例
let al2 = {
    length: 4,
    '-1': -1,
    '0': 0,
    a: 'a',
    1: 1
};
console.log(Array.prototype.slice.call(al2)); //[0, 1, empty × 2]
```

1. 使用数组方法操作类数组注意地方

```javascript
  let arrayLike2 = {
    2: 3,
    3: 4,
    length: 2,
    push: Array.prototype.push
  }

  // push 操作的是索引值为 length 的位置
  arrayLike2.push(1);
  console.log(arrayLike2); // {2: 1, 3: 4, length: 3, push: ƒ}
  arrayLike2.push(2);
  console.log(arrayLike2); // {2: 1, 3: 2, length: 4, push: ƒ}
```





### 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

**参考答案**：

**Set**

1. 成员不能重复；
2. 只有键值，没有键名，有点类似数组；
3. 可以遍历，方法有add、delete、has

**WeakSet**

1. 成员都是对象（引用）；
2. 成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露；
3. 不能遍历，方法有add、delete、has；

**Map**

1. 本质上是键值对的集合，类似集合；
2. 可以遍历，方法很多，可以跟各种数据格式转换；

**WeakMap**

1. 只接收对象为键名（null 除外），不接受其他类型的值作为键名；
2. 键名指向的对象，不计入垃圾回收机制；
3. 不能遍历，方法同get、set、has、delete；






### 简单说说 js 中有哪几种内存泄露的情况

**参考答案**：

1. 意外的全局变量；![img](https://img-blog.csdnimg.cn/20201022153055274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDA2MQ==,size_16,color_FFFFFF,t_70)(启用严格模式可避免)
2. 闭包；![69802962897](D:\MyProject\HTMLCSSJavaScript\面试准备\assets\1698029628978.png)
3. 未被清空的定时器；
4. 清除页面dom元素时，dom元素绑定的事件未解绑
   解决办法：手工移除事件。
5. 循环引用；![69802975411](D:\MyProject\HTMLCSSJavaScript\面试准备\assets\1698029754117.png)





### 异步笔试题

[promise、async、await、settimeout异步原理与执行顺序 - Cristina_Guan - 博客园 (cnblogs.com)](https://www.cnblogs.com/cristina-guan/p/11487403.html)

[javascript - async/await 执行顺序详解 - 前端学习日记 - SegmentFault 思否](https://segmentfault.com/a/1190000011296839)

请写出下面代码的运行结果：

```JavaScript
// 今日头条面试题

async function async1() {

  console.log('async1 start')

  await async2()

  console.log('async1 end')

}

async function async2() {

  console.log('async2')

}

console.log('script start')

setTimeout(function () {

  console.log('settimeout')

})

async1()

new Promise(function (resolve) {

  console.log('promise1')

  resolve()

}).then(function () {

  console.log('promise2')

})

console.log('script end')
```

题目的本质，就是考察setTimeout、promise、async await的实现及执行顺序，以及 JS 的事件循环的相关问题。

答案：

```javascript
script start
async1 start
async2
promise1
script end
async1 end
promise2
settimeout
```



### json和xml数据的区别

**参考答案**：

1. 数据体积方面：xml是重量级的，json是轻量级的，传递的速度更快些。
2. 数据传输方面：xml在传输过程中比较占带宽，json占带宽少，易于压缩。
3. 数据交互方面：json与javascript的交互更加方便，更容易解析处理，更好的进行数据交互
4. 数据描述方面：json对数据的描述性比xml较差
5. xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互。





### JavaScript有几种方法判断变量的类型?

**参考答案**：

1. 使用**typeof**检测当需要判断变量是否是number, string, boolean, function, undefined等类型时，可以使用typeof进行判断。
2. 使用**instanceof**检测instanceof运算符与typeof运算符相似，用于识别正在处理的对象的类型。与typeof方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。
3. 使用**constructor**检测constructor本来是原型对象上的属性，指向构造函数。但是根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用constructor属性的。





### 代码解释题

**参考答案**：

题目：

```javascript
var min = Math.min();
max = Math.max();
console.log(min < max);
// 写出执行结果，并解释原因
```

**答案**
false

**解析**

- 按常规的思路，这段代码应该输出 true，毕竟最小值小于最大值。但是却输出 false
- MDN 相关文档是这样解释的
  - Math.min 的参数是 0 个或者多个，如果多个参数很容易理解，返回参数中最小的。如果没有参数，则返回 Infinity，无穷大。
  - 而 Math.max 没有传递参数时返回的是-Infinity.所以输出 false



### 代码解析题

**参考答案**：

**题目**

```javascript
var company = {
    address: 'beijing'
}
var yideng = Object.create(company);
delete yideng.address
console.log(yideng.address);
// 写出执行结果，并解释原因
```

**答案**
beijing

**解析**
这里的 yideng 通过 prototype 继承了 company的 address。yideng自己并没有address属性。所以delete操作符的作用是无效的，**如果我们访问yideng.address的话是通过作用域链访问到的yideng的原型链的属性**。

> **扩展**
>
> 1.delete使用原则：delete 操作符用来删除一个对象的属性。
> 2.delete在删除一个不可配置的属性时在严格模式和非严格模式下的区别:
> （1）在严格模式中，如果属性是一个不可配置（non-configurable）属性，删除时会抛出异常;
> （2）非严格模式下返回 false。
> 3.delete能删除隐式声明的全局变量：这个全局变量其实是global对象(window)的属性
> 4.delete能删除的：
> （1）可配置对象的属性（2）隐式声明的全局变量 （3）用户定义的属性 （4）在ECMAScript 6中，通过 const 或 let 声明指定的 "temporal dead zone" (TDZ) 对 delete 操作符也会起作用
> delete不能删除的：
> （2）显式声明的全局变量 （2）内置对象的内置属性 （3）一个对象从原型继承而来的属性
> 5.delete删除数组元素：
> （1）当你删除一个数组元素时，数组的 length 属性并不会变小，数组元素变成undefined
> （2）当用 delete 操作符删除一个数组元素时，被删除的元素已经完全不属于该数组。
> （3）如果你想让一个数组元素的值变为 undefined 而不是删除它，可以使用 undefined 给其赋值而不是使用 delete 操作符。此时数组元素是在数组中的
> 6.delete 操作符与直接释放内存（只能通过解除引用来间接释放）没有关系。





## 异步相关

### promise怎么捕获异常

在promise的实例方法.then的第二个参数传入回调函数 或者 是使用实例方法.catch进行捕获



### Promise中的then第二个参数和catch有什么区别

主要区别就是：**如果在.then方法的第一个函数内出现异常，那么只有.catch可以捕获到，而.then的第二个函数捕获不到**

> 补充：
>
> then的第二个参数和catch捕获错误信息的时候会遵循**就近原则**，即当如果是promise内部报错，reject抛出错误后，then的第二个参数和catch方法都存在的情况下，只有then的第二个参数能捕获到





### promise和 async await 区别

**参考答案：**

- **概念**
  **Promise** 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的

  **async await**也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象。

- ##### 两者的区别

  1. Promise的出现解决了传统callback函数导致的“回调函数地狱”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。
  2. async await与Promise一样，是非阻塞的。
  3. async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。




### defer和async区别

[defer和async的区别（面试被问到了） - 掘金 (juejin.cn)](https://juejin.cn/post/7063464864542359583)

**参考答案：**

区别主要在于一个执行时间点,defer会在文档(HTML)解析完之后执行,并且多个defer会按照顺序执行,而async则是在js加载(下载)好之后就会执行,并且多个async,哪个加载好就执行哪个

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/894d84e8a7e0497091a26e43e1a84237~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

**解析：**

在没有defer或者async的情况下：会立即执行脚本,所以通常建议把script放在body最后

```javascript
<script src="script.js"></script>
```

async：有async的话,加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。
但是多个js文件的加载顺序不会按照书写顺序进行

```javascript
<script async src="script.js"></script>
```

defer：有defer的话,加载后续文档元素(HTML)的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成,并且多个defer会按照顺序进行加载。

```javascript
<script defer src="script.js"></script>
```





### 同步和异步

**参考答案：**

同步

- 指在 **主线程**上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。
- 也就是调用一旦开始，必须这个调用 **返回结果**(划重点——）才能继续往后执行。程序的执行顺序和任务排列顺序是一致的。

异步

- 异步任务是指不进入主线程，而进入 **任务队列**的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。
- 每一个任务有一个或多个 **回调函数**。前一个任务结束后，不是执行后一个任务,而是执行回调函数，后一个任务则是不等前一个任务结束就执行。
- 程序的执行顺序和任务的排列顺序是**不一致**的，异步的。
- 我们常用的setTimeout和setInterval函数，Ajax都是异步操作。





### 实现异步的方法

**参考答案：**

==**回调函数（Callback）、事件监听、发布订阅、Promise、生成器Generators/ yield、async/await**==

1. JS 异步编程进化史：callback -> promise -> generator -> async + await

2. async/await 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。

3. async/await可以说是异步终极解决方案了。

   (1) async/await函数相对于Promise，优势体现在：

   - 处理 then 的调用链，能够更清晰准确的写出代码
   - 并且也能优雅地解决回调地狱问题。

   当然async/await函数也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。

   (2) async/await函数对 Generator 函数的改进，体现在以下三点：

   - 内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，**async 函数的执行，与普通函数一模一样，只要一行**。
   - 更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 **async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）**。
   - 更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。

**解析：**

1. **回调函数（Callback）**

   回调函数是异步操作最基本的方法。以下代码就是一个回调函数的例子：

   ```javascript
   ajax(url, () => {
       // 处理逻辑
   })
   ```

   但是回调函数有一个致命的弱点，就是容易写出**回调地狱（Callback hell）**。假设多个请求存在依赖性，你可能就会写出如下代码：

   ```javascript
   ajax(url, () => {
       // 处理逻辑
       ajax(url1, () => {
           // 处理逻辑
           ajax(url2, () => {
               // 处理逻辑
           })
       })
   })
   ```

   回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。此外它不能使用 try catch 捕获错误，不能直接 return。

2. 事件监听

   这种方式下，**异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生**。

   下面是两个函数f1和f2，编程的意图是f2必须等到f1执行完成，才能执行。首先，为f1绑定一个事件（这里采用的jQuery的写法）

   ```javascript
   f1.on('done', f2);
   ```

   上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：

   ```javascript
   function f1() {
     setTimeout(function () {
       // ...
       f1.trigger('done');
     }, 1000);
   }
   ```

   上面代码中，f1.trigger('done')表示，执行完成后，立即触发done事件，从而开始执行f2。

   这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以"去耦合"，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。

3. 发布订阅

   我们假定，存在一个"信号中心"，某个任务执行完成，就向信号中心"发布"（publish）一个信号，其他任务可以向信号中心"订阅"（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做"发布/订阅模式"（publish-subscribe pattern），又称"观察者模式"（observer pattern）。

   首先，f2向信号中心jQuery订阅done信号。

   ```javascript
   jQuery.subscribe('done', f2);
   ```

   然后，f1进行如下改写：

   ```javascript
   function f1() {
     setTimeout(function () {
       // ...
       jQuery.publish('done');
     }, 1000);
   }
   ```

   上面代码中，jQuery.publish('done')的意思是，f1执行完成后，向信号中心jQuery发布done信号，从而引发f2的执行。 f2完成执行后，可以取消订阅（unsubscribe）

   ```javascript
   jQuery.unsubscribe('done', f2);
   ```

   这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

4. Promise

   Promise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果。 什么时候会用到过一段时间？答案是异步操作，异步是指可能比较长时间才有结果的才做，例如网络请求、读取本地文件等

   4.1 Promise的三种状态

   - **Pending----Promise对象实例创建时候的初始状态**
   - **Fulfilled----可以理解为成功的状态**
   - **Rejected----可以理解为失败的状态**

   ![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646121826353/AE8F5B0E5132A5E6C19BCE0A3065045C)

   **这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了**，比如说一旦状态变为 resolved 后，就不能 再次改变为Fulfilled

   ```javascript
   let p = new Promise((resolve, reject) => {
     reject('reject')
     resolve('success')//无效代码不会执行
   })
   p.then(
     value => {
       console.log(value)
     },
     reason => {
       console.log(reason)//reject
     }
   )
   ```

   当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的

   ```javascript
   new Promise((resolve, reject) => {
     console.log('new Promise')
     resolve('success')
   })
   console.log('end')
   // new Promise => end
   ```





### promise的链式调用

- 每次调用返回的都是一个新的Promise实例(这就是then可用链式调用的原因)

- 如果then中返回的是一个结果的话会把这个结果传递下一次then中的成功回调

- 如果then中出现异常,会走下一个then的失败回调

- 在 then中使用了return，那么 return 的值会被Promise.resolve() 包装(见例1，2)

- then中可以不传递参数，如果不传递会透到下一个then中(见例3)

- catch 会捕获到没有捕获的异常

  接下来我们看几个例子：

  ```JavaScript
  // 例1
  Promise.resolve(1)
  .then(res => {
    console.log(res)
    return 2 //包装成 Promise.resolve(2)
  })
  .catch(err => 3)
  .then(res => console.log(res))
  复制代码
  // 例2
  Promise.resolve(1)
  .then(x => x + 1)
  .then(x => {
    throw new Error('My Error')
  })
  .catch(() => 1)
  .then(x => x + 1)
  .then(x => console.log(x)) //2
  .catch(console.error)
  复制代码
  // 例3
  let fs = require('fs')
  function read(url) {
  return new Promise((resolve, reject) => {
    fs.readFile(url, 'utf8', (err, data) => {
      if (err) reject(err)
      resolve(data)
    })
  })
  }
  read('./name.txt')
  .then(function(data) {
    throw new Error() //then中出现异常,会走下一个then的失败回调
  }) //由于下一个then没有失败回调，就会继续往下找，如果都没有，就会被catch捕获到
  .then(function(data) {
    console.log('data')
  })
  .then()
  .then(null, function(err) {
    console.log('then', err)// then error
  })
  .catch(function(err) {
    console.log('error')
  })
  ```

  Promise不仅能够捕获错误，而且也很好地解决了回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：

  ```JavaScript
  ajax(url)
  .then(res => {
      console.log(res)
      return ajax(url1)
  }).then(res => {
      console.log(res)
      return ajax(url2)
  }).then(res => console.log(res))
  ```

  它也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。



### 生成器Generators/ yield与async/ await

1. 生成器Generators/ yield

   Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 最大的特点就是可以控制函数的执行。

   - 语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。

   - **Generator 函数除了状态机，还是一个遍历器对象生成函数**。

   - **可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果**。

   - yield表达式本身没有返回值，或者说总是返回undefined。**next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值**。

     我们先来看个例子：

   ```
   function *foo(x) {
     let y = 2 * (yield (x + 1))
     let z = yield (y / 3)
     return (x + y + z)
   }
   let it = foo(5)
   console.log(it.next())   // => {value: 6, done: false}
   console.log(it.next(12)) // => {value: 8, done: false}
   console.log(it.next(13)) // => {value: 42, done: true}
   ```

   可能结果跟你想象不一致，接下来我们逐行代码分析：

   - 首先 Generator 函数调用和普通函数不同，它会返回一个迭代器

   - 当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6

   - 当执行第二次 next 时，传入的参数12就会被当作上一个yield表达式的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8

   - 当执行第三次 next 时，传入的参数13就会被当作上一个yield表达式的返回值，所以 z = 13, x = 5, y = 24，相加等于 42

     我们再来看个例子：有三个本地文件，分别1.txt,2.txt和3.txt，内容都只有一句话，下一个请求依赖上一个请求的结果，想通过Generator函数依次调用三个文件

     ```
     1.txt
     //1.txt文件
     ```

     ```
     2.txt
     //2.txt文件
     ```

     ```
     3.txt
     //3.txt文件
     ```

     ```
     let fs = require('fs')
     function read(file) {
       return new Promise(function(resolve, reject) {
         fs.readFile(file, 'utf8', function(err, data) {
           if (err) reject(err)
           resolve(data)
         })
       })
     }
     function* r() {
       let r1 = yield read('./1.txt')
       let r2 = yield read(r1)
       let r3 = yield read(r2)
       console.log(r1)
       console.log(r2)
       console.log(r3)
     }
     let it = r()
     let { value, done } = it.next()
     value.then(function(data) { // value是个promise
       console.log(data) //data=>2.txt
       let { value, done } = it.next(data)
       value.then(function(data) {
         console.log(data) //data=>3.txt
         let { value, done } = it.next(data)
         value.then(function(data) {
           console.log(data) //data=>结束
         })
       })
     })
     ```

   从上例中我们看出手动迭代Generator函数很麻烦，实现逻辑有点绕，而实际开发一般会配合co库去使用。**co是一个为Node.js和浏览器打造的基于生成器的流程控制工具，借助于Promise，你可以使用更加优雅的方式编写非阻塞代码**。

   安装co库只需：npm install co

   上面例子只需两句话就可以轻松实现

   ```
   function* r() {
     let r1 = yield read('./1.txt')
     let r2 = yield read(r1)
     let r3 = yield read(r2)
     console.log(r1)
     console.log(r2)
     console.log(r3)
   }
   let co = require('co')
   co(r()).then(function(data) {
     console.log(data)
   })
   // 2.txt=>3.txt=>结束=>undefined
   ```

   我们可以通过 Generator 函数解决回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：

   ```
   function *fetch() {
       yield ajax(url, () => {})
       yield ajax(url1, () => {})
       yield ajax(url2, () => {})
   }
   let it = fetch()
   let result1 = it.next()
   let result2 = it.next()
   let result3 = it.next()
   ```


1. async/await

   5.1 Async/Await简介

   使用async/await，你可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点：

   1. async/await是基于Promise实现的，它不能用于普通的回调函数。
   2. async/await与Promise一样，是非阻塞的。

   ```
        3. async/await使得异步代码看起来像同步代码，这正是它的魔力所在。
   ```

**一个函数如果加上 async ，那么该函数就会返回一个 Promise**

```
   async function async1() {
     return "1"
   }
   console.log(async1()) // -> Promise {<resolved>: "1"}
```

Generator函数依次调用三个文件那个例子用async/await写法，只需几句话便可实现

```
   let fs = require('fs')
   function read(file) {
     return new Promise(function(resolve, reject) {
       fs.readFile(file, 'utf8', function(err, data) {
         if (err) reject(err)
         resolve(data)
       })
     })
   }
   async function readResult(params) {
     try {
       let p1 = await read(params, 'utf8')//await后面跟的是一个Promise实例
       let p2 = await read(p1, 'utf8')
       let p3 = await read(p2, 'utf8')
       console.log('p1', p1)
       console.log('p2', p2)
       console.log('p3', p3)
       return p3
     } catch (error) {
       console.log(error)
     }
   }
   readResult('1.txt').then( // async函数返回的也是个promise
     data => {
       console.log(data)
     },
     err => console.log(err)
   )
   // p1 2.txt
   // p2 3.txt
   // p3 结束
   // 结束
```



### 怎么解决callback多层嵌套

**参考答案：**

回调地狱有两种解决方案：

1. Promises
2. Async/await




### 作用域面试题

循环i，setTimeout 中输出什么，如何解决（块级作用域，函数作用域）

**for循环setTimeout输出1-10解决方式问题来源**

```js
for (var i = 0; i< 10; i++){
   setTimeout((i) => {
   console.log(i);
   }, 0)
}
```

期望：输出1到10

为什么无法输出1到十

在上面的代码中，for循环是同步代码，setTimeout是异步代码。遇到这种既包含同步又包含异步的情况，JavaScript依旧按照从上到下的顺序执行同步代码，并将异步代码插入任务队列。setTimeout的第二个参数则是把执行代码（console.log(i)）添加到任务队列需等待的毫秒数，但等待的时间是相对主程序完毕的时间计算的，也就是说，在执行到setTimeout函数时会等待一段时间，再将当前任务插入任务队列。
最后，当执行完同步代码，js引擎就会去执行任务队列中的异步代码。这时候任务队列中就会有十个console.log(i)。我们知道，在每次循环中将setTimeout里面的代码“console.log(i)”放入任务队列时，i的值都是不一样的。但JavaScript引擎开始执行任务队列中的代码时，会开始在当前的作用域中开始找变量i，但是当前作用域中并没有对变量i进行定义。这个时候就会在创造该函数的作用域中寻找i。创建该函数的作用域就是全局作用域，这个时候就找到了for循环中的变量i，这时的i是全局变量，并且值已经确定：10。十个console.log“共享”i的值。这就是作用域链的问题。

**解决方法**

- 方法一

```js
for (var i = 0; i< 10; i++){
   setTimeout((i) => {
      console.log(i)
   }, 1000,i);
}
```

> 最精简解决方案

- 方法二

```js
for (let i = 0; i< 10; i++){
   setTimeout(() => {
      console.log(i) 
   }, 1000);
}
```

> 最优解决方案，利用let形成块级作用域

- 方法三

```js
    for (var i = 0; i< 10; i++){
      ((i)=>{
        setTimeout(() => {
          console.log(i)
        },1000);
      })(i)
    }
```

> IIFE(立即执行函数)，类似于let生成了块级作用域。

- 方法四

```js
for (var i = 0; i< 10; i++){
   setTimeout(console.log(i),1000);
}
```

> 直接输出，没有延迟

- 方法五

```js
for (var i = 0; i< 10; i++){
   setTimeout((()=>console.log(i))(),1000);
}
```

> 同上

- 方法六

```js
for (var i = 0; i< 10; i++){
      try{
        throw i
      }catch(i){
        setTimeout(() => {
          console.log(i)
        }, 1000)
      }
}
console.time('start');

setTimeout(function() {
  console.log(2);
}, 10);

setImmediate(function() {
  console.log(1);
});

new Promise(function(resolve) {
  console.log(3);
  resolve();
  console.log(4);
}).then(function() {
  console.log(5);
  console.timeEnd('start')
});

console.log(6);

process.nextTick(function() {
  console.log(7);
});

console.log(8);
```





## this

### call appy bind的作用和区别

作用：

都可以改变函数内部的this指向。

区别点：

1. call 和 apply 会调用函数，并且改变函数内部this指向。
2. call 和 apply 传递的参数不一样，call 传递参数arg1,arg2...形式 apply 必须数组形式[arg]
3. bind 不会调用函数，可以改变函数内部this指向。

**解析：**

**call方法**

改变函数内部this指向

call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的this指向。

写法：fun.call(thisArg, arg1, arg3, ...) // thisArg为想要指向的对象，arg1,arg3为参数

call 的主要作用也可以实现继承

```js
function Person(uname, age) {
    this.uname = uname;
    this.age = age;
  }
  function Son(uname, age) {
    Person.call(this, uname, age);
  }
  var son = new Son("zhang", 12);
  console.log(son);
```

**apply方法**

apply()方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的this指向。

写法：fun.apply(thisArg, [argsArray])

- thisArg:在fun函数运行时指定的this值
- argsArray:传递的值，必须包含在数组里面
- 返回值就是函数的返回值，因为他就是调用函数

apply的主要应用，比如可以利用apply可以求得数组中最大值

```js
const arr = [1, 22, 3, 44, 5, 66, 7, 88, 9];
const max = Math.max.apply(Math, arr);
console.log(max);
```

**bind方法**

bind()方法不会调用函数，但是能改变函数内部this指向

写法：fun.bind(thisArg, arg1, arg2, ...)

- thisArg:在fun函数运行时指定的this值
- arg1,arg2:传递的其他参数
- 返回由指定的this值和初始化参数改造的原函数拷贝

```js
var o = {
    name: "lisa"
};
function fn() {
    console.log(this);
}
var f = fn.bind(o);
f();
```

bind应用

如果有的函数我们不需要立即调用，但是又需要改变这个函数的this指向，此时用bind再合适不过了

```js
const btns = document.querySelectorAll("button");
for (let i = 0; i < btns.length; i++) {
    btns[i].onclick = function() {
      this.disabled = true;
      setTimeout(
        function() {
          this.disabled = false;
        }.bind(this),
        2000
      );
    };
}
```

**扩展:**

主要应用场景：

1. call 经常做继承。
2. apply 经常跟数组有关系，比如借助于数学对象实现数组最大值最小值。
3. bind 不调用函数，但是还想改变this指向，比如改变定时器内部的this指向。






### this的指向（普通函数、箭头函数）

- 普通函数


1. 谁调用了函数或者方法，那么这个函数或者对象中的this就指向谁

```js
        let getThis = function () {
            console.log(this);
        }

        let obj={
            name:"Jack",
            getThis:function(){
                console.log(this);
            }
        }
        //getThis()方法是由window在全局作用域中调用的，所以this指向调用该方法的对象，即window
        getThis();//window
        //此处的getThis()方法是obj这个对象调用的，所以this指向obj
        obj.getThis();//obj
```



2. 匿名函数中的this：匿名函数的执行具有全局性，则匿名函数中的this指向是window，而不是调用该匿名函数的对象；

```js
   let obj = {
            getThis: function () {
                return function () {
                    console.log(this);
                }
            }
        }
        obj.getThis()(); //window
```

上面代码中，getThis()方法是由obj调用，但是obj.getThis()返回的是一个匿名函数，而匿名函数中的this指向window，所以打印出window。 如果想在上述代码中使this指向调用该方法的对象，可以提前把this传值给另外一个变量(_this或者that)：

```js
       let obj = {
            getThis: function () {
            //提前保存this指向
                let _this=this
                return function () {
                    console.log(_this);
                }
            }
        }
        obj.getThis()(); //obj
```



- 箭头函数

1. 箭头函数中的this是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的；
2. 箭头函数中的this指向父级作用域的执行上下文；（技巧：**因为javascript中除了全局作用域，其他作用域都是由函数创建出来的，所以如果想确定this的指向，则找到离箭头函数最近的function，与该function平级的执行上下文中的this即是箭头函数中的this**）
3. 箭头函数无法使用apply、call和bind方法改变this指向，因为其this值在函数定义的时候就被确定下来。

例1：首先，距离箭头函数最近的是getThis(){}，与该函数平级的执行上下文是obj中的执行上下文，箭头函数中的this就是下注释代码处的this，即obj。

```js
        let obj = {
            //此处的this即是箭头函数中的this
            getThis: function () {
                return  ()=> {
                    console.log(this);
                }
            }
        }
        obj.getThis()(); //obj
```

例2：该段代码中存在两个箭头函数，this找不到对应的function(){}，所以一直往上找直到指向window。

```js
        //代码中有两个箭头函数，由于找不到对应的function，所以this会指向window对象。
       let obj = {
            getThis: ()=> {
                return  ()=> {
                    console.log(this);
                }
            }
        }
        obj.getThis()(); //window
```



### 箭头函数能否用于构造函数

**参考答案：**

**箭头函数表达式**的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它==不能==用作构造函数。



### new会发生什么

1. 创建空对象；
   var obj = {};
2. 设置新对象的constructor属性为构造函数的名称，设置新对象的**proto**属性指向构造函数的prototype对象；
   obj.**proto** = ClassA.prototype;
   扩展了新对象的原型链。
3. 使用新对象调用函数，函数中的this被指向新实例对象：
   ClassA.call(obj);　　//{}.构造函数();
4. 返回this指针。当存在显示的返回时，返回return后面的内容。新建的空对象作废。



## 文件引入方式

### link和@import

- 相同点：都可以导入样式

link 的使用

```js
<link href="index.css" rel="stylesheet">
```

@import 的使用

```js
<style type="text/css">
@import url(index.css);
</style>
```

- 区别

1. 引入的内容不同

   link 除了引用样式文件，还可以引用图片等资源文件，而 @import 只引用样式文件

2. 加载顺序不同

   link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载

3. 兼容性不同

   link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持

4. 对 JS 的支持不同

   link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持



### 为什么使用link用href获取资源 script和img用src

**参考答案：**

src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。

- src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素

  ```js
  <script src ="js.js"></script> 
  ```

当浏览器解析到该元素时，**会暂停其他资源的下载和处理**，直到将该资源加载、编译、执行完毕，图片和框架 等元素也如此，类似于将所指向资源嵌入当前标签内。**这也是为什么将js脚本放在底部而不是头部**

- href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接
- 在文档中添加link标签，浏览器会识别该文档为css文件，就会**并行下载资源**并且**不会**停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式





## ES6

### 箭头函数

- 箭头函数与普通函数的区别：
  - 语法更加简洁清晰
  - 箭头函数不会创建自己的this，它会捕获自己在**定义时**（注意，是定义时，不是调用时）所处的**外层执行环境的this**，并继承这个this值。所以，箭头函数中this的指向在它被定义的时候就已经确定了，之后**永远不会改变**
  - call/apply/bind都无法改变箭头函数的this指向
  - 箭头函数不能作为构造函数使用(构造函数的new都做了些什么？简单来说，分为四步： ① JS内部首先会先生成一个对象； ② 再把函数中的this指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例。)
  - 箭头函数没有自己的arguments对象
  - 箭头函数没有原型prototype
  - 箭头函数不能用作Generator函数，不能使用yield

### 变量和作用域

- let 、const、 块级作用域和变量声明
  - let声明的变量**只在所在块中生效**；
  - let声明的变量**不存在变量提升**、也不允许重复声明；
  - const声明的变量行为与let类似，只是多了**两点更强的约束：1.声明时必须赋值；2.声明的变量内存地址不可变，需要注意的是**：对于用const声明基本类型，值就保存在内存地址之中，意味着变量不可重新赋值；对于用const声明的对象，对象内容还是可以更改的，只是不能改变其指向。
- 解构赋值



### 原生对象的方法扩展

- String
  - 加强了对unicode的支持、支持字符串遍历（后面有讲到实际上是部署了iterator接口）、repeat()等方法的支持、**模板字符串**
- RegExp
- Number
  - 二进制和八进制新写法、新方法parseInt()、Number.EPSILON极小常量、安全整数、Math新方法
- Function
  - **函数参数默认值**、rest参数、**函数内部严格模式**、函数的name属性、**箭头函数**
- Array
  - **扩展运算符...**(复杂数据类型都可以，当要转化为可迭代数据结构时可设置对象的迭代器对扩展运算符扩展出来的值进行操作，基础数据类型只有string可以使用扩展运算符)
- Object 
  - Object.is()
  - Object.assign()——将src的所有可枚举对象属性复制到dest对象上（浅复制）
  - Object.setPrototypeOf()、Object.getPrototypeOf() (Object.__proto属性)
  - Object.entries()、Object.keys()、Object.values()
  - ES6中5种遍历对象属性的方法
    - for in
    - Object.keys()
    - **Object.getOwnPropertyNames()**
    - **Object.getOwnPropertySymbols()**
    - **Reflect.ownKeys()**
- Symbol类型
  - ES5以前，对象属性都只能是字符串，容易造成重命名导致的冲突。Symbol提供了一种机制，可以保存 属性名是独一无二的。
  - Symbol类型的使用注意：
    - 1）创建是调用函数，而不是new关键字
    -  2）Symbol类 型的属性不会被for-*、Object.keys()、Object.getPropertyNames()返回，可以用后面两种方法遍历。



### 数据结构Set和Map

Set是一种类似数组的数据结构，区别在于其存储的成员都是不重复的，由此带来了它的一个应用就是：**去重**。Set通过new关键字实例化，入参可以是数组or类数组的对象。

值得注意的是：在Set中，只能存储一个NaN，**这说明在Set数据结构中，NaN等于NaN**

WeakSet类似于Set，**主要区别在于1.成员只能是对象类型；2.对象都是弱引用**（如果其他对象都不再引用该对象，垃圾回收机制会自动回收该对象所占的内存，不可预测何时会发生，故WeakSet不可被遍历

</hr>

JavaScript对象Object都是键值K-V对的集合，但K取值只能是字符串和Symbol，Map也是K-V的集合，然而其K可以取任意类型。如果需要键值对的集合，Map比Object更适合。Map通过new关键字实例化。

Map实例的方法：set()、get()、has()、delete()和clear();遍历方法同Set。

Map与其它数据结构的互相转换：Map <---> 数组| Map <---> 对象| Map <---> JSON。

WeakMap类似于Map，主要区别在于：**1.只接受对象作为键名；2.键名所指向的对象不计入垃圾回收机制**。



### 类class的支持

从 ES6 开始，JavaScript 提供了 class 关键字来定义类，尽管，这样的方案仍然是基于原型运行时系统的模拟，大部分功能ES5可以实现。

构造函数的prototype属性在 ES6 的“类”上面继续存在。事实上，类中所有方法都定义在类的prototype属性上面（因而也是不可枚举的）。

constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。（默认构造函数）；constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。

注意区别：**类必须使用**new**调用，否则会报错**。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。

类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。

实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。

私有属性和方法如何实现？1.命名上加以区别 2.将私有方法移出模块，利用公有方法调用；3.Symbol属性上（都不完美）





### Iterator

ES6之前在JS中只有Array和对象可以表示“集合”这种数据结构，ES6中增加了：Set和Map。由此，四种之间互相组合又可以定义新的数据结构。这些**新定义的数据结构如何访问呢？遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制**。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。遍历器对象本质上是一个指针对象。

只要为某个数据结构部署 了Iterator接口，则可以称此数据结构是可遍历的。iterator属性部署在Symbol上。如下对象默认部署了Iterator结口：Array Set Map String等。部署iterator结构的**要点：1）在Symbol.iterator上部署；2）必须包含next()函数**。默认调用iterator接口的场景：解构赋值、...扩展运算符、yeild* 。for-of循环内部调用的即是调用数据机构内部的Symbol.iterator方法。

- **for-in和for-of循环**
  - for-in用于遍历对象属性，对象自身和继承的可枚举属性（不可遍历Symbol属性）
  - for-of循环是一种遍历所有数据机构的统一方法。实现原理是数据结构上部署的Symbol.iterator属性。



### 异步编程

- Promise
  - Promise来源于社区，代表一个对象，它代表异步操作未来的一个结果（承诺）。它总共有**三个状态**，**pending\fulfilled\rejected**。另外，它的状态**翻转路径只有两个**：pending->fulfilled or pending->rejected，**一旦状态翻转，就不可变了**
  - 理解为：对异步代码的管理(（可以理解resolve和reject是已返回的承诺对象未来回调函数的占位）)
- Generator
  - 对于Generator函数，可以将它**理解为一个状态机，封装了多个内部状态；此外它还是一个遍历器生成函数**，这个函数可以遍历出状态机的所有状态
  - 函数特征：关键字function与函数名之间有*，函数体内部yeild关键字。
  - **生成器函数与普通函数的区别**：函数调用后不执行，而是返回一个指针对象（遍历器对象）。调用对象的next()方法，执行一段yield逻辑。故函数的分段执行的，**yield是暂停执行的标志，next()可以恢复执行**
- **async函数**
  - 是Generator函数的语法糖，它进行了**改进：1.自带执行器；2.返回值是Promise;**






## JS工作原理

### 为什么JS是单线程

这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变

> 什么是进程？
>
> 进程：是cpu分配资源的最小单位；（是能拥有资源和独立运行的最小单位）
>
> 什么是线程？
>
> 线程：是cpu调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
>
> 浏览器是多进程的？
>
> 放在浏览器中，每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。 所以，浏览器是一个多进程的。
>
> 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。



### 宏微队列及执行顺序

JS 中用来存储待执行回调函数的队列包含 2 个不同特定的列队

- **宏列队**：用来保存待执行的宏任务（回调），比如：定时器回调、DOM 事件回调、ajax 回调
- **微列队**：用来保存待执行的微任务（回调），比如：promise的回调、MutationObserver 的回调

JS 执行时会区别这 2 个队列

- JS 引擎首先必须先执行所有的初始化同步任务代码
- 每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行，也就是优先级比宏任务高，且与微任务所处的代码位置无关

下面这个例子可以看出Promise要先于setTimeout执行：

```js
　　setTimeout(() => { //立即放入宏队列
      console.log('timeout callback1（）')
      Promise.resolve(3).then(
        value => { //立即放入微队列
          console.log('Promise onResolved3()', value)
        }
      )
    }, 0)

    setTimeout(() => { //立即放入宏队列
      console.log('timeout callback2（）')
    }, 0)

    Promise.resolve(1).then(
      value => { //立即放入微队列
        console.log('Promise onResolved1()', value)
        setTimeout(() => {
          console.log('timeout callback3（）', value)
        }, 0)
      }
    )

    Promise.resolve(2).then(
      value => { //立即放入微队列
        console.log('Promise onResolved2()', value)
      }
    )

    // Promise onResolved1() 1
    // Promise onResolved2() 2
    // timeout callback1（）
    // Promise onResolved3() 3
    // timeout callback2（）
    // timeout callback3（） 1
```



### 死锁

**死锁是指两个或两个以上的进程在执行过程中，由于竞争资源而造成阻塞的现象，若无外力作用，它们都将无法继续执行**

产生原因

- 竞争资源引起进程死锁
- 可剥夺和非剥夺资源
- 竞争非剥夺资源
- 竞争临时性资源
- 进程推进顺序不当

产生条件

1. 互斥条件：涉及的资源是非共享的
   - 涉及的资源是非共享的,一段时间内某资源只由一个进程占用,如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放
2. 不剥夺条件：不能强行剥夺进程拥有的资源
   - 进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放
3. 请求和保持条件：进程在等待一新资源时继续占有已分配的资源
   - 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放 环路等待条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求 在发生死锁时，必然存在一个进程——资源的环形链

解决办法

只要打破四个必要条件之一就能有效预防死锁的发生



### 暂时性死区

**暂时性死区的本质**就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

- let 、const与暂时性死区

**let或const声明的变量拥有暂时性死区**（TDZ）：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明

生命周期如下：

- 当进入let变量的作用域（包围它的语法块），立即为它创建（绑定）存储空间。此时变量仍是未初始化的。
- 获取或设置未初始化的变量将抛出异常ReferenceError。
- 当执行到变量声明的时候，如果变量定义了值则会被赋值。如果没有定义值，则赋值为undefined。

const工作方式与let类似，但是定义的时候必须赋值并且不能改变。

- var不拥有暂时性死区

当进入var变量的作用域（包围它的函数），立即为它创建（绑定）存储空间。变量会立即被初始化并赋值为undefined。

当执行到变量声明的时候，如果变量定义了值则会被赋值

> typeof与暂时性死区
>
> 变量在暂时性死区无法被访问，所以无法对它使用typeof：
>
> ```js
> if (true) {
>     console.log(typeof tmp); // ReferenceError
>     let tmp;
> }
> ```



###  面向对象的三个特征，分别说一下什么意思

概念：

**封装：**将对象运行所需的资源封装在程序对象中——基本上，是方法和数据。对象是“公布其接口”。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。这个概念就是“不要告诉我你是怎么做的，只要做就可以了。”对象可以看作是一个自我包含的原子。对象接口包括了公共的方法和初始化数据。

**继承：** 继承可以解决代码复用，让编程更加靠近人类思维。当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过继承父类中的属性和方法。

**多态：** 多态是指一个引用(类型)在不同情况下的多种状态。也可以理解成：多态是指通过指向父类的引用，来调用在不同子类中实现的方法。

特点：

**封装**可以隐藏实现细节，使得代码模块化；

**继承**可以扩展已存在的代码模块（类），它们的目的都是为了——代码重用。

**多态**就是相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。多态分为两种，一种是行为多态与对象的多态





## CSS & 布局

### 移动端适配方案

[移动端适配的5种方案 - 掘金 (juejin.cn)](https://juejin.cn/post/6953091677838344199#heading-4)



# 前端进阶

## 浏览器

### cookie sessionStorage localStorage 区别

- 共同点：都是保存在浏览器端、且同源的
- 区别：
  - **数据有效期**不同，**sessionStorage：仅在当前浏览器窗口关闭之前有效**；**localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭**
  - **作用域**不同，**sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面**；**localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的**
  - **存储大小**限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以**cookie只适合保存很小的数据**，如会话标识。**sessionStorage和localStorage**虽然也有存储大小的限制，**但比cookie大得多**，可以达到5M或更大
  - **cookie数据**始终在同源的http请求中携带（即使不需要），即c**ookie在浏览器和服务器间来回传递**，而**sessionStorage和localStorage**不会自动把数据发送给服务器，**仅在本地保存**。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
  - web Storage的api接口使用更方便
  - web Storage支持事件通知机制，可以将数据更新的通知发送给监听者




### 一个页面从输入URL到页面加载显示完成，这个过程都发生什么

一般会经历以下几个过程：

1. 在浏览器地址栏中输入URL
2. 浏览器需要对输入域名解析，因此查看缓存中是否包含DNS记录，没有则跳到第3步
3. 在发送HTTP请求前，进行域名解析(DNS解析)，解析获取对应IP地址
4. 浏览器向服务器发送TCP连接请求，进行三次握手建立连接
5. 连接成功后，浏览器即可向服务器发送HTTP请求获取数据包
6. 服务器处理收到的请求，将数据返回给浏览器
7. 浏览器得到http响应
8. 读取响应内容，浏览器解析并渲染html源码
9. 解析HTML生成DOM树，解析CSS样式生成规则树、JS引擎解析JS代码、绘制页面
10. 渲染完毕，四次挥手，关闭tcp连接

其中，步骤2的具体过程是(**在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址**)：

- **浏览器缓存**：浏览器会记录DNS一段时间，因此，这是第一个解析DNS请求的缓存地点；
- **操作系统缓存：**如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)；
- **路由器缓存**：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
- **ISP缓存：**若上述均失败，继续向ISP(互联网服务提供商)搜索。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201108221347486.png#pic_center)

> 简易版：
>
> 1. URL 解析(域名解析)
> 2. TCP 三次握手建立连接
> 3. 发请求
> 4. 服务器处理请求
> 5. 浏览器接受响应
> 6. 渲染页面
> 7. 四次挥手断开连接



### 浏览器如何渲染页面的？

1. HTML 被 HTML 解析器解析成 DOM 树；


2. CSS 被 CSS 解析器解析成 CSSOM 树；
   1. 结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；
   2. 生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；
   3. 将布局绘制(paint)在屏幕上，显示出整个页面。

   不同的浏览器内核不同，所以渲染过程不太一样。

![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646126562376/09B5557937394BD994ACE3C49F7AECC4)





### 重绘与重排

1. 重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。
2. 重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等
3. 区别：**重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）**

- 引发重排的原因：

1.  添加、删除可见的dom
2. 元素的位置改变
3. 元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)
4. 页面渲染初始化
5. 浏览器窗口尺寸改变
6. 获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。



### let声明的全局变量存在哪里

使用let声明的全局变量不是挂在window对象下的，声明的全局变量存在于一个块级作用域中。

具体查看，我们可以通过打印一个全局函数，在let声明的全局变量在全局函数的scope下，我们平时使用时直接 用变量名称就能访问到

具体位置如下图：
![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646126617426/B742135235F1E65B51FA2D04FF2A9F43)





### 垃圾回收机制

**垃圾回收机制（Garbage Collection）简称GC**

JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器，自动回收

#### 内存的生命周期

1. 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
2. 内存使用：即读写内存
3. 内存回收：使用完毕，垃圾回收器自动回收不再使用的内存

> 说明：
>
> - 全局变量一般不会回收(关闭页面回收)
> - 一般情况下，局部变量的值，不用了，就会被自动回收
> - **内存泄漏**：程序中分配的内存由于某种原因程序未释放或无法释放叫做内存泄漏



#### 算法说明

> 堆栈空间分配说明：
>
> 1. 栈(操作系统):由**操作系统自动分配释放**函数的参数值、局部变量等，**基本数据类型放到栈**中
> 2. 堆(操作系统):一般由程序员分配释放，若**程序员不释放，由垃圾回收机制回收**，**复杂数据类型放到堆**中

##### 引用计数法

 IE采用的引用计数算法，定义“内存不再使用”，就是看一个**对象**是否有指向它的引用，没有引用了就回收对象

算法：

- 跟踪记录被引用的次数
- 如果被引用了一次，那么就记录次数1，多次引用会累加++
- 如果减少一个引用就减1
- 如果引用次数为0，就释放内存

> **缺点：**
>
> 如果两个对象相互引用，即使它们已经不再使用，垃圾回收器也不会进行回收，导致内存泄漏
>
> ![69241917291](D:\MyProject\HTMLCSSJavaScript\JavaScript\笔记\assets\1692419172913.png)
>
> 这样的函数每次调用都会导致内存泄漏



##### 标记清除法

核心：

- 标记清除算法将“不再使用的对象”重新定义为“**无法达到的对象**”
- 就是从**根部**(在JS中就是全局对象)出发定时扫描内存中的对象，**凡是能够从根部到达的对象，都是需要使用的**
- 那些**无法由根部出发触及的对象被标记为不再使用**，稍后**进行回收**

![69241950414](D:\MyProject\HTMLCSSJavaScript\JavaScript\笔记\assets\1692419504147.png)



### token与cookie

- token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，token 便应运而生。
- **「简单 token 的组成」**:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）

**token认证流程**

**![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646126713615/A15371DCA92780086ECA57869EEE4AA4)**

1. 客户端使用用户名跟密码请求登录
2. 服务端收到请求，去验证用户名与密码
3. 验证成功后，服务端签发一个 token ，并把它发送给客户端
4. 客户端接收 token 以后会把它存储起来，比如放在 cookie 里或者 localStorage 里
5. 客户端每次发送请求时都需要带着服务端签发的 token（把 token 放到 HTTP 的 Header 里）
6. 服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据



### cookie

#### 什么是cookie

- cookie 是存储于访问者计算机中的变量。每当一台计算机通过浏览器来访问某个页面时，那么就可以通过 JavaScript 来创建和读取 cookie。
- 实际上 cookie 是存于用户硬盘的一个文件，这个文件通常对应于一个域名，当浏览器再次访问这个域名时，便使这个cookie可用。因此，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。
- 不同浏览器对 cookie 的实现也不一样。即保存在一个浏览器中的 cookie 到另外一个浏览器是 不能获取的。

PS：cookie 和 session 都能保存计算机中的变量，但是 session 是运行在服务器端的，而客户端我们只能通过 cookie 来读取和创建变量



#### cookie有什么用

- 用户在第一次登录某个网站时，要输入用户名密码，如果觉得很麻烦，下次登录时不想输入了，那么就在第一次登录时将登录信息存放在 cookie 中。下次登录时我们就可以直接获取 cookie 中的用户名密码来进行登录。

  PS:虽然 浏览器将信息保存在 cookie 中是加密了，但是可能还是会造成不安全的信息泄露

- 类似于购物车性质的功能，第一次用户将某些商品放入购物车了，但是临时有事，将电脑关闭了，下次再次进入此网站，我们可以通过读取 cookie 中的信息，恢复购物车中的物品。

  PS：实际操作中，这种方法很少用了，基本上都是将这些信息存储在数据库中。然后通过查询数据库的信息来恢复购物车里的物品

- 页面之间的传值。在实际开发中，我们往往会通过一个页面跳转到另外一个页面。后端服务器我们可以通过数据库，session 等来传递页面所需要的值。但是在浏览器端，我们可以将数据保存在 cookie 中，然后在另外页面再去获取 cookie 中的数据。

  PS：这里要注意 cookie 的时效性，不然会造成获取 cookie 中数据的混乱。



#### 怎么使用cookie

- 语法

  **document.cookie = "name=value;expires=evalue; path=pvalue; domain=dvalue; secure;”**

- 对各个参数的解释

  1. name=value 必选参数

这是一个键值对，分别表示要存入的 属性 和 值。

比如：

```js
document.cookie="name=中文";
//为了防止中文乱码，我们可以使用encodeURIComponent()编码；decodeURIComponent()解码
document.cookie = encodeURIComponent("name")+"="+encodeURIComponent("中文");
```

2. expires=evalue 可选参数

该对象的有效时间（可选）只支持GTM 标准时间，即要将时间转换，toUTCString()（默认为当前浏览器 会话有用，关闭浏览器就消失）;

比如：

```js
var date = new Date(); 　
date.setTime(date.getTime()+2000);//获取当前时间并加上 2 秒钟 　
alert(date.toUTCString());//格林威治时间 (GMT) 把 Date 对象转换为字符串，并返回结果
alert(date.toGMTString());//与上面的结果一样，但是这个方法已经被上面取代了 
document.cookie="name=vae;expires="+date.toUTCString(); 
alert(document.cookie); // name=vae 　
setTimeout(function(){alert(document.cookie)},4000);//4 秒后打印空的字符串
```

3. path=pvalue 可选参数

限制访问 cookie 的目录，默认情况下对于当前网页所在的同一目录下的所有页面有效

4.domain=dvalue 可选参数

用于限制只有设置了的域名才可以访问；如果没有设置，则默认在当前域名访问

比如设置 test*.com 表示域名为test*.com的服务器共享该Cookie

5.secure=true|false 可选参数，默认是 true 不安全传输

安全设置，指明必须通过 安全的通信通道来传输（https) 才能获得 cookie,true 不安全，默认值；false 安 全，必须通过 https 来访问

比如：如果你设置 document.cookie = "name=vae;secure"

上面的代码如果是在 http 的协议中访问，那么是访问不了的

```js
　　　　　　　//设置 cookie
            function setCookie(objName, objValue, objHours){//添加cookie
                var str = objName + "=" + encodeURIComponent(objValue);
                if (objHours > 0) {//为0时不设定过期时间，浏览器关闭时cookie自动消失
                    var date = new Date();
                    var ms = objHours * 3600 * 1000;
                    date.setTime(date.getTime() + ms);
                    str += "; expires=" + date.toUTCString();
                }
                document.cookie = str;

            }
            //获取 cookie
            function getCookie(objName){//获取指定名称的cookie的值
                //多个cookie 保存的时候是以 ;空格  分开的
                var arrStr = document.cookie.split("; ");
                for (var i = 0; i < arrStr.length; i++) {
                    var temp = arrStr[i].split("=");
                    if (temp[0] == objName){
                        return decodeURIComponent(temp[1]);
                    }else{
                        return "";
                    }

                }
            }

            //为了删除指定名称的cookie，可以将其过期时间设定为一个过去的时间
            function delCookie(name){
                var date = new Date();
                date.setTime(date.getTime() - 10000);
                document.cookie = name + "=a; expires=" + date.toUTCString();
            }
```

注意：

（1）cookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；

（2）cookie是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的cookie也是不能互相访问的；

（3）cookie可能被删除。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除；

（4）cookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。

（5）cookie 在保存时，只要后面保存的 name 相同，那么就会覆盖前面的 cookie，注意是完全覆盖，包括失效时间，pat





### 如何写一个会过期的localStorage，说说想法

**两种方案：惰性删除 和 定时删除**

**惰性删除**

惰性删除是指，某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。我们先来简单实现一下：

```js
var lsc = (function (self) {
    var prefix = 'one_more_lsc_'
    /**
     * 增加一个键值对数据
     * @param key 键
     * @param val 值
     * @param expires 过期时间，单位为秒
     */
    self.set = function (key, val, expires) {
        key = prefix + key;
        val = JSON.stringify({'val': val, 'expires': new Date().getTime() + expires * 1000});
        localStorage.setItem(key, val);
    };
    /**
     * 读取对应键的值数据
     * @param key 键
     * @returns {null|*} 对应键的值
     */
    self.get = function (key) {
        key = prefix + key;
        var val = localStorage.getItem(key);
        if (!val) {
            return null;
        }
        val = JSON.parse(val);
        if (val.expires < new Date().getTime()) {
            localStorage.removeItem(key);
            return null;
        }
        return val.val;
    };
    return self;
}(lsc || {}));
```

上述代码通过惰性删除已经实现了可过期的localStorage缓存，但是也有比较明显的缺点：如果一个key一直没有被用到，即使它已经过期了也永远存放在localStorage。为了弥补这样缺点，我们引入另一种清理过期缓存的策略。

**定时删除**

定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。

每隔一秒执行一次定时删除，操作如下：

1. 随机测试20个设置了过期时间的key。
2. 删除所有发现的已过期的key。
3. 若删除的key超过5个则重复**步骤1**，直至重复500次。

具体实现如下：

```js
var lsc = (function (self) {
    var prefix = 'one_more_lsc_'
    var list = [];
    //初始化list
    self.init = function () {
        var keys = Object.keys(localStorage);
        var reg = new RegExp('^' + prefix);
        var temp = [];
        //遍历所有localStorage中的所有key
        for (var i = 0; i < keys.length; i++) {
            //找出可过期缓存的key
            if (reg.test(keys[i])) {
                temp.push(keys[i]);
            }
        }
        list = temp;
    };
    self.init();
    self.check = function () {
        if (!list || list.length == 0) {
            return;
        }
        var checkCount = 0;
        while (checkCount < 500) {
            var expireCount = 0;
            //随机测试20个设置了过期时间的key
            for (var i = 0; i < 20; i++) {
                if (list.length == 0) {
                    break;
                }
                var index = Math.floor(Math.random() * list.length);
                var key = list[index];
                var val = localStorage.getItem(list[index]);
                //从list中删除被惰性删除的key
                if (!val) {
                    list.splice(index, 1);
                    expireCount++;
                    continue;
                }
                val = JSON.parse(val);
                //删除所有发现的已过期的key
                if (val.expires < new Date().getTime()) {
                    list.splice(index, 1);
                    localStorage.removeItem(key);
                    expireCount++;
                }
            }
            //若删除的key不超过5个则跳出循环
            if (expireCount <= 5 || list.length == 0) {
                break;
            }
            checkCount++;
        }
    }
    //每隔一秒执行一次定时删除
    window.setInterval(self.check, 1000);
    return self;
}(lsc || {}));
```




## 网络传输

### **HTTP和HTTPS**

- 都是从服务器传输超文本到本地浏览器的传输协议
- 只不过HTTPS = SSL(加密协议) + HTTP

> HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
>
> HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
>
> HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。
>
> **2.HTTP与HTTPS有什么区别？**
>
> HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证 这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。
>
> HTTPS和HTTP的区别主要如下：
>
> 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
>
> 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
>
> 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
>
> 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。



### HTTP缓存机制

[彻底弄懂HTTP缓存机制及原理 - 云中桥 - 博客园 (cnblogs.com)](https://www.cnblogs.com/chenqf/p/6386163.html)

#### 介绍HTTP报文

HTTP报文就是浏览器和服务器间通信时发送及响应的数据块

浏览器向服务器请求数据，发送请求(request)报文；

服务器向浏览器返回数据，返回响应(response)报文。
报文信息主要分为两部分：

1. 包含属性的首部(header)---附加信息（cookie，缓存信息等）**与缓存相关的规则信息，均包含在header中**
2. 包含数据的主体部分(body)---HTTP请求真正想要传输的部分

#### 缓存规则解析

我们认为浏览器存在一个缓存数据库,用于存储缓存信息

在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中，因此下次请求同样的数据时可以直接从浏览器的缓存数据库中得到，提高性能

![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141639213-1923993391.png)

HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)
在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解

已存在缓存数据时，仅基于强制缓存，请求数据的流程如下

![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210135521072-1812985836.png)
已存在缓存数据时，仅基于对比缓存，请求数据的流程如下
![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141716838-764535017.png)

我们可以看到两类缓存规则的**不同**，**强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互**。
两类缓存规则可以同时存在，**强制缓存优先级高于对比缓存**，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。

##### 强制缓存

从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？

我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中

对于强制缓存来说，响应header中会有两个字段来标明失效规则（**Expires/Cache-Control**）
使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况
![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141755072-1978466289.png)

###### Expires

Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。
不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。
另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。
所以HTTP 1.1 的版本，使用Cache-Control替代。



###### Cache-Control

Cache-Control 是最重要的字段。常见的取值有private、public、no-cache、max-age，no-store，默认为private。

| 值          | 涵义                                             |
| ----------- | ------------------------------------------------ |
| private     | 客户端可以缓存                                   |
| public      | 客户端和代理服务器都可缓存                       |
| max-age=xxx | 缓存的内容将在 xxx 秒后失效                      |
| no-cache    | 需要使用对比缓存来验证缓存数据                   |
| no-store    | 所有内容都不会缓存，强制缓存，对比缓存都不会触发 |

举个板栗
![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141836104-1513192908.png)
图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）
也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。



##### 对比缓存

对比缓存，顾名思义，需要进行**比较判断**是否可以使用缓存。
浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。
再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。

**第一次访问：**
![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141911682-1756976419.png)
**再次访问：**
![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141921697-379821074.png)

通过两图的对比，我们可以很清楚的发现，在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少。
原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。

对于对比缓存来说，**缓存标识的传递**是我们着重需要理解的，它在请求header和响应header间进行传递，
一共分为两种标识传递，接下来，我们分开介绍。

###### **Last-Modified  /  If-Modified-Since**

- **Last-Modified**：

服务器在响应请求时，告诉浏览器资源的最后修改时间。

![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142249541-789089587.png)

- **If-Modified-Since**：

再次请求服务器时，浏览器通过此字段通知服务器上次返回的资源最后修改时间是多少

服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对

若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；
若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器可以继续使用所保存的cache

![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142307166-135607673.png)

###### **Etag  /  If-None-Match**

该种缓存标识优先级较大（优先级高于Last-Modified  /  If-Modified-Since）

**- Etag：**
服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。

![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142054182-1766818273.png)
**If-None-Match：**
再次请求服务器时，通过此字段通知服务器客户端缓存数据的唯一标识。
服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，
不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；
相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。

![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142115479-1921175758.png)



##### 总结

**对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。**

**浏览器第一次请求：**
![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142134291-1976923079.png)

**浏览器再次请求时：**
![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141453338-1263276228.png)





### 如何优化首屏加载时间

1. **http缓存（强制缓存和对比缓存)**, 性价比最高的一个优化方式。需注意的是，浏览器不缓存XHR接口，自己可根据业务特性动态地选择缓存策略。比如一个体积很大的接口，但内容变更频率不是很频繁，这种情况就适合用对比缓存。

2. **cdn分发**（减少传输距离）。通过在多台服务器部署相同的副本，当用户访问时，dns服务器就近（物理距离）选择一台文件服务器并返回它的ip。

3. 前端的资源动态加载：

4. 1. **路由动态加载**
   2. **组件动态加载**
   3. **图片懒加载**(offScreen Image)，越来越多的浏览器支持原生的懒加载，通过给img标签加上loading="lazy来开启懒加载模式。

5. 合并请求。这点在串行接口的场景中作用很明显，比如有两个串行的接口A和B，需要先请求A，然后根据接口A的返回结果去请求接口B。假如server和client的物理距离为D，那么这个串行的场景传输的物理路程为4D。如果合并成一个接口，物理路程可减小为2D。

6. 页面使用骨架屏。意思是在首屏加载完成之前，通过渲染一些简单元素进行占位。骨架屏的好处在于可以减少用户等待时的急躁情绪。这点很有效，在很多成熟的网站都有大量应用。没有骨架屏的话，一个loading图也是可以的。

7. 使用ssr渲染。

8. service worker：通过sw离线更新缓存的能力，理论上能做到每次访问页面都无需下载html，且所有静态资源都已经在本地有缓存。

9. 引入[http2.0](https://link.zhihu.com/?target=https%3A//www.digitalocean.com/community/tutorials/http-1-1-vs-http-2-what-s-the-difference)。http2.0对比http1.1，最主要的提升是传输性能，在接口小而多的时候性能优势会更加明显。

10. 利用好http压缩。即使是最普通的gzip，也能把bootstrap.min.css压缩到原来的17%。可见，压缩的效果非常明显，特别是对于文本类的静态资源。另外，接口也是能压缩的。接口不大的话可以不用压缩，因为性价比低（考虑压缩和解压的时间）。值得注意的是，因为压缩算法的特性，文件越大，压缩效果会越好。


10. 利用好script标签的[async和defer](https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/10808109/script-tag-async-defer)这两个属性。

![img](https://pic3.zhimg.com/80/v2-640a2f9d1d6347505b38628a8530fe0a_720w.webp)

11. 使用 WebP 代替jpg/png。

> WebP lossless images are [26% smaller](https://link.zhihu.com/?target=https%3A//developers.google.com/speed/webp/docs/webp_lossless_alpha_study%23results) in size compared to PNGs. WebP lossy images are [25-34% smaller](https://link.zhihu.com/?target=https%3A//developers.google.com/speed/webp/docs/webp_study) than comparable JPEG images at equivalent [SSIM](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Structural_similarity) quality index. --by Google Developers



### get和post的区别

[HTTP 方法：GET 对比 POST | 菜鸟教程 (runoob.com)](https://www.runoob.com/tags/html-httpmethods.html)



### visibility：hidden; opacity：0; display：none区别

* **display: none;**

1、浏览器不会生成属性为display: none;的元素。
2、display: none;不占据空间（毕竟都不渲染啦），所以动态改变此属性时会引起重排。
3、display: none;不会被子类继承，但是···子类是不会显示的，毕竟都一起被kill啦。
4、display,是个尴尬的属性，transition对她无效。(毫无争议)

- **visibility: hidden;**

1、元素会被隐藏，但是不会消失，依然占据空间。
2、visibility: hidden会被子类继承，子类也可以通过显示的设置visibility: visible;来反隐藏。
3、visibility: hidden;不会触发该元素已经绑定的事件。
4、visibility: hidden;动态修改此属性会引起重绘。
5、visibility,transition对她无效。(亲测)

- **opacity=0**

1、opacity=0只是透明度为100%,元素隐藏，依然占据空间。
2、opacity=0会被子元素继承,且，子元素并不能通过opacity=1，进行反隐藏。不能。
3、opacity=0的元素依然能触发已经绑定的事件。
4、opacity,transition对她有效(毫无争议)







# 框架面试题

## Vue面试题

### 响应式丢失的场景及处理

#### Vue3

- **场景1：响应式数据解构后丢失响应式**
  - 例如通过defineProps传给组件的数据进行解构传递给函数
  - 解构相当于将该变量重新赋给(**基础数据是传值，引用类型是传地址**)了一个新变量，所以解构之后是一个基础数据则会响应式丢失。如果解构之后是一个引用类型，相当于操作的地址还是被Proxy监管，所以响应式不会丢失。
  - 比如解构之后是基础类型的数据，那么解构相当于copy了一个值。访问时直接访问的这个copy值，跳过了代理，所以不会触发`get`和`set`。
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/7712826a191543cdba98e0e37452f2ff.png)
  - **解决办法**： ``toRefs``/``toRef``方法创建ref引用对象
  - `toRef(响应式对象，该对象的属性)`创建一个`ref对象`，`该ref对象`的`value`值指向参数对象中的某个属性
    **ref对象的value值改变，参数对象中的该属性也会改变,反之也会改变，因为指向同一个地址！本质是引用，与原始数据有关联**
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/97419ce09154482eba92c4b3452278b2.png)
  - `toRefs(obj)`：返回一个和参数一致的普通对象，只不过属性的值都变成了ref对象，相当于每个属性都执行了一次`toRef`。



#### Vue2

- **场景1：对象新增属性丢失响应式**

  - ```js
     data(){
     return{
       obj:{
       a:1
     }
     }}
       methods:{
      fn1(){
         this.obj.a++   //有响应
      }
      fn2(){
        this.obj.b=2   //无响应
       }
     ```
    ```

  - 解决方案``this.$set(target, key, value)``，这是vue2官方提供的方法

  - ```js
       fn3(){
       //this.$set('对象','添加的属性',新值) 
         this.$set(this.obj,'c',3)  //有响应
        }
    ```

- **场景2：对象删除属性丢失响应式**

  - 解决方案``this.$delete(target, key)``，这是vue2官方提供的方法

- **场景3：数组通过下标直接赋值丢失响应式**

  - 解决方案``this.$set(target, key, value)``，这是vue2官方提供的方法

  - ```js
    let arr=[1,2,3,4]
    fn3(){
        //老方法:
        //this.arr[0]=100  //无响应式
        //新方法  使用$set()
        //this.$set('数组','下标',值)  //有响应
          this.$set('this.arr','0',100) //arr=[100,2,3,4]
        }
    }
    ```

- **场景4：修改数组的length丢失响应式**



### 路由切换的权限管理实现

- 思路

  1.通过router.beforeEach() 路由拦截的方式实现。

  2.通过vue-router 官方提供的addRoutes()来进行动态路由注入，`注意` 该方法只有vue-router的版本 `>= 2.2`才有效。

#### 路由拦截

这种方式依赖于我们项目的路由表都是事先配置好的，假设我们的路由表有：

```js
const router = new Router({
  routes: [{
        path: '/',
        redirect: '/index1'
    }, {
        path: '/index1',
        name: 'Index1',
        component: Index1
    }, {
        path: '/index2',
        name: 'Index2',
        component: Index2
    }, {
        path: '/index3',
        name: 'Index3',
        component: Index3
    }]
})

export default router;
```

在 `router/index` 中，通过router.beforeEach() 路由拦截去进行权限判断：

```js
router.beforeEach((to, from, next) => {
    //to: 从哪个路由来
    //from: 去哪个路由
    //next：是一个方法，使用路由拦截，必须在后面添加next()，否则路由无法跳转

    //假设我们从后台获取的当前用户路由权限为：
    const list = ['index1', 'index2'];

    //如果没有匹配到，证明没有权限
    if(list.indexOf(to.name) === -1) {
        //next('/login');

        ... //或者执行其他操作
    }

    //路由拦截可根据项目返回的权限自行调整，这里只是做了一个简单的例子
})
```



#### 动态注入路由

这种方式我们只需要配置静态的路由表，比如登录、注册页，需要权限的其他路由通过动态注入：

```js
const router = new Router({
  routes: [{
        path: '/',
        redirect: '/login'
    }, {
        path: '/login',
        name: 'login',
        component: Login
    }]
})

export default router;
```

假设我们在 登录 的时候，后端返回的权限列表如下：

```js
//leaf: 是我们用来判断是否唯一的
//component：一般来说后端返回给我们的就是一个路径而已，所以我们需要自行的去加载组件
export const routers = [{
    path: '/main',
    name: 'main',
    leaf: false,
    component: 'pages/main',
    children: [{
        path: '/main/index1',
        name: 'index1',
        component: 'pages/index1',
        leaf: true
    }, {
        path: '/main/index2',
        name: 'index2',
        component: 'pages/index2',
        leaf: true
    }, {
        path: '/main/index3',
        name: 'index3',
        component: 'pages/index3',
        leaf: true
    }, {
        path: '/main/index4',
        name: 'index4',
        component: 'pages/index4',
        leaf: true
    }]
}, {
    path: '*',
    component: 'pages/noFind',
    leaf: true
}]
```

可以写个方法去再次过滤返回回来的路由列表

```js
/**
 * @param routers 初始数据，为数组格式，一般来说是个空数组
 * @param data 后端返回的路由列表数据
 */
function generaMenu(routers, data) {
  data.forEach((item)=>{
    let menu = Object.assign({},item);
    menu.component = import(`@/${menu.component}.vue`);
    if(!item.leaf) {
      menu.children = [];
      generaMenu(menu.children,item.children);
        menu.redirect = menu.children[0].path; //如果需要重定向的话，可以根据自己的需求进行选择
    }
    routers.push(menu);
  })
}
```

`注意` 如果有用到404的路由话，需要把404这个路由放到整个路由表的最后一个，否则，因为一开始我们是没有对应的动态路由，默认就跳转到了404页面了，所以静态路由表不配置404路由，与动态路由一起注入到路由表中。

这样我们最终就得到了符合路由规则的路由表了。然后通过 `addRoutes()` 这个方法把路由给注入到路由表里面，之后就可以访问已注入的路由了：

```js
this.$route.addRoutes(data);
```

`注意` 因为使用了addRoutes()这个方法之后，路由表已经可以认为是不可控的了，也就是说，已经注入的路由，没办法在通过官方给的api删除掉(当然，目前官方也没有提供相应的api)。那当我们A帐号退出之后，B帐号登录进来，也会执行 `addRoutes()` 这个方法，会一直累加上去，然后控制台上也会有警告，出现了重复的路由，然后我们访问A帐号有，B帐号没有的路由时，发现是可以进行访问的。这显然不符合我们的需求。

那么，我们该如何解决这个问题呢？

一种是在用户退出的时候，进行项目的重载：

```js
location.href = '/'; //这种相对来说体验就非常差了，相当于重新刷新了页面，显然也是不符合我们的需求
```

还有一种就是重新初始化静态路由表： 首先，我们要对 `router/index` 进行改造一下：

```js
const createRouter = () => new Router({
  routes: [{
    path: '/',
    redirect: '/login'
  }, {
    path: '/login',
    name: 'login',
    component: Login
  }]
})

const router = createRouter()

//重新实例化一个新的路由表，替换之前的路由表，然后将这个方法导出
export function resetRouter() {
  const newRouter = createRouter();
  router.matcher = newRouter.matcher; // the relevant part
}
```

然后，我们在用户退出的时候，重新执行下 `resetRouter()` 这个方法就可以重新初始化静态路由表，同时也发现B账号进来之后，只能访问对应的路由权限而已。A账号的权限路由已经不存在了。

> [vue如何实现路由权限控制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/55262808#:~:text=%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%20%E7%9B%AE%E5%89%8D%E5%A4%A7%E6%A6%82%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%80%9D%E8%B7%AF%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%EF%BC%9A%201.%E9%80%9A%E8%BF%87router.beforeEach%20%28%29%20%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E3%80%82%202.%E9%80%9A%E8%BF%87vue-router,%E5%AE%98%E6%96%B9%E6%8F%90%E4%BE%9B%E7%9A%84addRoutes%20%28%29%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%85%A5%EF%BC%8C%20%E6%B3%A8%E6%84%8F%20%E8%AF%A5%E6%96%B9%E6%B3%95%E5%8F%AA%E6%9C%89vue-router%E7%9A%84%E7%89%88%E6%9C%AC%20%3E%3D%202.2%20%E6%89%8D%E6%9C%89%E6%95%88%E3%80%82)



### 多组件动态渲染

使用Vue内置特殊组件``component``实现即可

[内置特殊元素 | Vue.js (vuejs.org)](https://cn.vuejs.org/api/built-in-special-elements.html#component)

[内置特殊元素 | Vue.js (vuejs.org)](https://cn.vuejs.org/api/built-in-special-elements.html#component)



### Axios内的请求拦截器和响应拦截器你一般做什么

- 请求拦截器：设置请求头，例如将用户登录的标识token添加到请求头中
- 响应拦截器：可以判断登录是否过期/用户未登录，会报状态码401，此时判断一下后进行路由导航即可



### Vue2与Vue3的区别

- Vue3相比Vue2的**优势点**

![69820378940](D:\MyProject\HTMLCSSJavaScript\Vue\assets\1698203789402.png)

- 使用**TypeScript**对代码重构了，因此Vue3更支持TypeScript
- Vue2使用的是**Object.defineProperty方法**对数据进行劫持，而Vue3使用的是**proxy**
- Vue3主推**组合式API**，可以将模块相关代码放在同一个地方
- Vue3默认使用**vite**对项目进行构建，体验下来更快



### Vue的响应式原理

[getter - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#%E5%B0%9D%E8%AF%95%E4%B8%80%E4%B8%8B)

[setter - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set)

[深入浅出Vue响应式原理（完整版） - 掘金 (juejin.cn)](https://juejin.cn/post/6844903882208837640)



### 说说异步组件

在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 [`defineAsyncComponent`](https://cn.vuejs.org/api/general.html#defineasynccomponent) 方法来实现此功能：

```javascript
import { defineAsyncComponent } from 'vue'

const AsyncComp = defineAsyncComponent(() => {
  return new Promise((resolve, reject) => {
    // ...从服务器获取组件
    resolve(/* 获取到的组件 */)
  })
})
// ... 像使用其他一般组件一样使用 `AsyncComp`
```

如你所见，`defineAsyncComponent` 方法接收一个返回 Promise 的加载函数。这个 Promise 的 `resolve` 回调方法应该在从服务器获得组件定义时调用。你也可以调用 `reject(reason)` 表明加载失败。

[ES 模块动态导入](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import)也会返回一个 Promise，所以多数情况下我们会将它和 `defineAsyncComponent` 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue 单文件组件：

```javascript
import { defineAsyncComponent } from 'vue'

const AsyncComp = defineAsyncComponent(() =>
  import('./components/MyComponent.vue')
)
```

最后得到的 `AsyncComp` 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。

与普通组件一样，异步组件可以使用 `app.component()` [全局注册](https://cn.vuejs.org/guide/components/registration.html#global-registration)：

```javascript
app.component('MyComponent', defineAsyncComponent(() =>
  import('./components/MyComponent.vue')
))
```

也可以直接在父组件中直接定义它们：

```javascript
<script setup>
import { defineAsyncComponent } from 'vue'

const AdminPage = defineAsyncComponent(() =>
  import('./components/AdminPageComponent.vue')
)
</script>

<template>
  <AdminPage />
</template>
```

> 异步操作不可避免地会涉及到加载和错误状态，因此 `defineAsyncComponent()` 也支持在高级选项中处理这些状态：
>
> ```javascript
> const AsyncComp = defineAsyncComponent({
>   // 加载函数
>   loader: () => import('./Foo.vue'),
>
>   // 加载异步组件时使用的组件
>   loadingComponent: LoadingComponent,
>   // 展示加载组件前的延迟时间，默认为 200ms
>   delay: 200,
>
>   // 加载失败后展示的组件
>   errorComponent: ErrorComponent,
>   // 如果提供了一个 timeout 时间限制，并超时了
>   // 也会显示这里配置的报错组件，默认值是：Infinity
>   timeout: 3000
> })
> ```
>
> 如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。
>
> 如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。



### Vue事件修饰符有哪些

修饰符是用 `.` 表示的指令后缀，包含以下这些：

- `.stop`
- `.prevent`
- `.self`
- `.capture`
- `.once`
- `.passive`

```javascript
<!-- 单击事件将停止冒泡 -->
<a @click.stop="doThis"></a>

<!-- 提交事件将不再重新加载页面(取消默认行为) -->
<form @submit.prevent="onSubmit"></form>

<!-- 修饰语可以使用链式书写 -->
<a @click.stop.prevent="doThat"></a>

<!-- 也可以只有修饰符 -->
<form @submit.prevent></form>

<!-- 仅当 event.target 是元素本身时才会触发事件处理器 -->
<!-- 例如：事件处理器不来自子元素 -->
<div @click.self="doThat">...</div>
```

> TIP
>
> 使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。因此使用 `@click.prevent.self` 会阻止**元素及其子元素的所有点击事件的默认行为**，而 `@click.self.prevent` 则只会阻止对元素本身的点击事件的默认行为。

`.capture`、`.once` 和 `.passive` 修饰符与[原生 `addEventListener` 事件](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#options)相对应：

```javascript
<!-- 添加事件监听器时，使用 `capture` 捕获模式 -->
<!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 -->
<div @click.capture="doThis">...</div>

<!-- 点击事件最多被触发一次 -->
<a @click.once="doThis"></a>

<!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 -->
<!-- 以防其中包含 `event.preventDefault()` -->
<div @scroll.passive="onScroll">...</div>
```

`.passive` 修饰符一般用于触摸事件的监听器，可以用来[改善移动端设备的滚屏性能](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD)。

> TIP
>
> 请勿同时使用 `.passive` 和 `.prevent`，因为 `.passive` 已经向浏览器表明了你*不想*阻止事件的默认行为。如果你这么做了，则 `.prevent` 会被忽略，并且浏览器会抛出警告。



### 按键修饰符

Vue 允许在 `v-on` 或 `@` 监听按键事件时添加按键修饰符。

template

```JavaScript
<!-- 仅在 `key` 为 `Enter` 时调用 `submit` -->
<input @keyup.enter="submit" />
```

你可以直接使用 [`KeyboardEvent.key`](https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent/key/Key_Values) 暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。

template

```JavaScript
<input @keyup.page-down="onPageDown" />
```

在上面的例子中，仅会在 `$event.key` 为 `'PageDown'` 时调用事件处理。

> Vue 为一些常用的按键提供了别名：
>
> - `.enter`
> - `.tab`
> - `.delete` (捕获“Delete”和“Backspace”两个按键)
> - `.esc`
> - `.space`
> - `.up`
> - `.down`
> - `.left`
> - `.right`
>
> 你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。
>
> - `.ctrl`
> - `.alt`
> - `.shift`
> - `.meta`
>
> ![70036349757](D:\MyProject\HTMLCSSJavaScript\面试准备\assets\1700363497572.png)
>
> 举例来说：
>
> ```JavaScript
> <!-- Alt + Enter -->
> <input @keyup.alt.enter="clear" />
>
> <!-- Ctrl + 点击 -->
> <div @click.ctrl="doSomething">Do something</div>
> ```
> `.exact` 修饰符
>
> `.exact` 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。
>
> ```javascript
> <!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 -->
> <button @click.ctrl="onClick">A</button>
>
> <!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 -->
> <button @click.ctrl.exact="onCtrlClick">A</button>
>
> <!-- 仅当没有按下任何系统按键时触发 -->
> <button @click.exact="onClick">A</button>
> ```



### 鼠标按键修饰符

- `.left`
- `.right`
- `.middle`

这些修饰符将处理程序限定为由特定鼠标按键触发的事件。




### v-model 作用？

**参考答案：**

v-model本质上不过是语法糖，可以用 v-model 指令在**表单**及**元素**上创建双向数据绑定。

1. 它会根据控件类型自动选取正确的方法来更新元素
2. 它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理
3. v-model会忽略所有表单元素的value、checked、selected特性的初始值,而总是将 Vue 实例的数据作为数据来源，因此我们应该通过 JavaScript 在组件的data选项中声明初始值

>  **扩展：**
>
> v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：
>
> 1. text 和 textarea 元素使用value属性和input事件；
> 2. checkbox 和 radio 使用checked属性和change事件；
> 3. select 字段将value作为 prop 并将change作为事件。



### v-model 实现原理？

**参考答案：**

v-model只不过是一个语法糖而已,真正的实现靠的还是

1. v-bind:绑定响应式数据
2. 触发input 事件并传递数据

```javascript
<input v-model="sth" />
<!-- 等同于-->
<input :value="sth" @input="sth = $event.target.value" />
<!--自html5开始,input每次输入都会触发oninput事件，所以输入时input的内容会绑定到sth中，于是sth的值就被改变-->
<!--$event 指代当前触发的事件对象;-->
<!--$event.target 指代当前触发的事件对象的dom;-->
<!--$event.target.value 就是当前dom的value值;-->
<!--在@input方法中，value => sth;-->
<!--在:value中,sth => value;-->
```



### Vue2.0 双向绑定的缺陷？

**参考答案：**

Vue2.0的数据响应是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty () 来劫持各个属性的setter、getter，但是它并不算是实现数据的响应式的完美方案，某些情况下需要对其进行修补或者hack这也是它的缺陷，主要表现在两个方面：

1. vue 实例创建后，无法检测到对象属性的新增或删除，只能追踪到数据是否被修改
2. 不能监听数组的变化

**解析：**

1. vue 实例创建后，无法检测到对象属性的新增或删除，只能追踪到数据是否被修改(Object.defineProperty只能劫持对象的属性)。

   当创建一个Vue实例时，将遍历所有DOM对象，并为每个数据属性添加了get和set。get和set 允许Vue观察数据的更改并触发更新。但是，如果你在Vue实例化后添加（或删除）一个属性，这个属性不会被vue处理，改变get和set。

   解决方案：

   ```javascript
   Vue.set(obj, propertName/index, value)
   // 响应式对象的子对象新增属性，可以给子响应式对象重新赋值
   data.location = {
       x: 100,
       y: 100
   }
   data.location = {...data, z: 100}
   ```

2. 不能监听数组的变化

   vue在实现数组的响应式时，它使用了一些hack，把无法监听数组的情况通过重写数组的部分方法来实现响应式，这也只限制在数组的push/pop/shift/unshift/splice/sort/reverse七个方法，其他数组方法及数组的使用则无法检测到，例如如下两种使用方式

   ```javascript
   vm.items[index] = newValue;
   vm.items.length
   ```

   vue实现数组响应式的方法

   通过重写数组的Array.prototype对应的方法，具体来说就是重新指定要操作数组的prototype，并重新该prototype中对应上面的7个数组方法，通过下面代码简单了解下实现原理：

   ```javascript
   const methods = ['pop','shift','unshift','sort','reverse','splice', 'push'];
   // 复制Array.prototype，并将其prototype指向Array.prototype
   let proto = Object.create(Array.prototype);
   methods.forEach(method => {
       proto[method] = function () { // 重写proto中的数组方法
           Array.prototype[method].call(this, ...arguments);
           viewRender() // 视图更新
           function observe(obj) {
               if (Array.isArray(obj)) { // 数组实现响应式
                   obj.__proto__ = proto; // 改变传入数组的prototype
                   return;
               }
               if (typeof obj === 'object') {
                   ... // 对象的响应式实现
               }
           }
       }
   })
   ```



### Vue3.0 实现数据双向绑定的原理

**参考答案:**[[Vue源码\]一起来学Vue双向绑定原理-数据劫持和发布订阅 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904022911139854?searchId=202311171037358791D144C68F3BBE2D96#heading-10)

vue3.0 实现数据双向绑定是通过**Proxy**

**Proxy**是 ES6 中新增的一个特性，翻译过来意思是"代理"，用在这里表示由它来“代理”某些操作。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。

> **扩展：**
>
> 使用proxy实现，双向数据绑定，相比2.0的Object.defineProperty ()优势：
>
> 1. 可以劫持整个对象，并返回一个新对象
> 2. 有13种劫持操作



### Vuex是什么，每个属性是干嘛的，如何使用

**参考答案：**

Vuex是什么？

Vuex是专门为Vuejs应用程序设计的**状态管理工具**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化

具体工作：vuex是一种状态管理机制，将全局组件的共享状态抽取出来为一个store，以一个单例模式存在，应用任何一个组件中都可以使用，vuex更改state的唯一途径是通过mutation，mutation需要commit触发, action实际触发是mutation，其中mutation处理同步任务，action处理异步任务。

Vuex每个属性是干嘛的？

![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128565972/EB5115B586566907B3B642BA58A4482A)

Vuex的属性包含以下6个：

1）state

state是存储的单一状态，是存储的基本数据。

2）Getters

getters是store的计算属性，对state的加工，是派生出来的数据。就像computed计算属性一样，getter返回的值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变才会被重新计算。

3）Mutations

mutations提交更改数据，使用store.commit方法更改state存储的状态。（mutations同步函数）

4）Actions

actions像一个装饰器，提交mutation，而不是直接变更状态。（actions可以包含任何异步操作）

5）Module

Module是store分割的模块，每个模块拥有自己的state、getters、mutations、actions。

```javascript
const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -> moduleA 的状态
store.state.b // -> moduleB 的状态
```

6）辅助函数

Vuex提供了mapState、MapGetters、MapActions、mapMutations等辅助函数给开发在vm中处理store。



### mutation和action有什么区别？

**参考答案：**

**mutation**：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于件： 每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进 行状态更改的地方，并且它会接受 state 作为第一个参数

```javascript
const store = new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      // 变更状态
      state.count++
    }
  }
})
```

不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：

```javascript
store.commit('increment')
```

**Action:** Action 类似于 mutation，不同在于：

1. Action 提交的是 mutation，而不是直接变更状态。

2. Action 可以包含任意异步操作。

   让我们来注册一个简单的 action：

```javascript
const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {
      context.commit('increment')
    }
  }
})
```





### 导航守卫

**参考答案：**

导航守卫主要用来**通过跳转或取消的方式守卫导航**。

简单的说，导航守卫就是路由跳转过程中的一些钩子函数。路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事儿的时机，这就是导航守卫。

**解析：**

路由守卫的具体方法：

1. 全局前置守卫

   你可以使用 router.beforeEach 注册一个全局前置守卫：

   ```javascript
   const router = new VueRouter({ ... })
   router.beforeEach((to, from, next) => {
     // ...
   })
   ```

   当一个导航开始时，全局前置守卫按照注册顺序调用。守卫是异步链式调用的，导航在最后的一层当中。

   ```javascript
   new Promise((resolve, reject) => {
       resolve('第一个全局前置守卫')
   }.then(() => {
       return '第二个全局前置守卫'
   }.then(() => {
       ...
   }.then(() => {
       console.log('导航终于开始了') // 导航在最后一层中
   })
   ```

每个守卫方法接收三个参数（往后的守卫都大同小异）：

1. to: Route: 即将要进入的目标 路由对象
2. from: Route: 当前导航正要离开的路由
3. next: Function: 一定要调用该方法将控制权交给下一个守卫，执行效果依赖 next 方法的参数。

next(): 进入下一个守卫。如果全部守卫执行完了。则导航的状态就是 confirmed (确认的)。

next(false): 中断当前的导航（把小明腿打断了）。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器 后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。

next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航（小 明被打断腿并且送回家了）。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。

next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递router.

onError() 注册过的回调。

注意：永远不要使用两次next，这会产生一些误会。

1. 全局解析守卫

   这和 router.beforeEach 类似，但他总是被放在最后一个执行。

2. 全局后置钩子

   导航已经确认了的，小明已经到了外婆家了，你打断他的腿他也是在外婆家了。

   ```javascript
   router.afterEach((to, from) => {
       // 你并不能调用next
     // ...
   })
   ```

3. 路由独享的守卫

   在路由内写的守卫

   ```javascript
   const router = new VueRouter({
     routes: [
       {
         path: '/foo',
         component: Foo,
         beforeEnter: (to, from, next) => {
           // ...
         }
       }
     ]
   })
   ```

4. 组件内的守卫

   5.1 beforeRouteEnter

   5.2 beforeRouteUpdate (2.2 新增)

   5.3 beforeRouteLeave

   ```javascript
   const Foo = {
     template: `...`,
     beforeRouteEnter (to, from, next) {
       // 路由被 confirm 前调用
       // 组件还未渲染出来，不能获取组件实例 `this`
     },
     beforeRouteUpdate (to, from, next) {
       // 在当前路由改变，但是该组件被复用时调用
       // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
       // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
       // 可以访问组件实例 `this`，一般用来数据获取。
     },
     beforeRouteLeave (to, from, next) {
       // 导航离开该组件的对应路由时调用
       // 可以访问组件实例 `this`
     }
   }
   ```



> **扩展：**
>
> 导航全过程
>
> - 导航被触发。
> - 在准备离开的组件里调用 beforeRouteLeave 守卫。
> - 调用全局的 beforeEach 守卫。
> - 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。（如果你的组件是重用的）
> - 在路由配置里调用 beforeEnter。
> - 解析即将抵达的组件。
> - 在即将抵达的组件里调用 beforeRouteEnter。
> - 调用全局的 beforeResolve 守卫 (2.5+)。
> - 导航被确认。
> - 调用全局的 afterEach 钩子。
> - 触发 DOM 更新。
> - 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。



### vue-router 实现懒加载

**参考答案：**

懒加载：当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。

实现：结合 Vue 的[异步组件](https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6)和 Webpack 的[代码分割功能](https://doc.webpack-china.org/guides/code-splitting-async/#require-ensure-/)，可以实现路由组件的懒加载

1. 首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)：

   ```javascript
   const Foo = () => Promise.resolve({ /* 组件定义对象 */ })
   ```

2. 在 Webpack 2 中，我们可以使用[动态 import](https://github.com/tc39/proposal-dynamic-import)语法来定义代码分块点 (split point)：

   ```javascript
   import('./Foo.vue') // 返回 Promise
   ```

   结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。

   ```javascript
   const Foo = () => import('./Foo.vue')
   ```

   在路由配置中什么都不需要改变，只需要像往常一样使用Foo：

   ```javascript
   const router = new VueRouter({
     routes: [
       { path: '/foo', component: Foo }
     ]
   })
   ```



### HashRouter 和 HistoryRouter的区别和原理

**参考答案：**

**vue-router**是Vue官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。vue-router默认 hash 模式，还有一种是history模式。

原理：

1. hash路由：hash模式的工作原理是hashchange事件，可以在window监听hash的变化。我们在url后面随便添加一个#xx触发这个事件。vue-router默认的是hash模式—使用URL的hash来模拟一个完整的URL,于是当URL改变的时候,页面不会重新加载,也就是单页应用了,当#后面的hash发生变化,不会导致浏览器向服务器发出请求,浏览器不发出请求就不会刷新页面,并且会触发hasChange这个事件,通过监听hash值的变化来实现更新页面部分内容的操作

   对于hash模式会创建hashHistory对象,在访问不同的路由的时候,会发生两件事:
   HashHistory.push()将新的路由添加到浏览器访问的历史的栈顶,和HasHistory.replace()替换到当前栈顶的路由

2. history路由：

   主要使用HTML5的pushState()和replaceState()这两个api结合window.popstate事件（监听浏览器前进后退）来实现的,pushState()可以改变url地址且不会发送请求,replaceState()可以读取历史记录栈,还可以对浏览器记录进行修改

区别：

1. hash模式较丑，history模式较优雅
2. pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL
3. pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中
4. pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串
5. pushState可额外设置title属性供后续使用
6. history模式需要后端配合将所有访问都指向index.html，否则用户刷新页面，会导致404错误

使用方法:

```javascript
<script>
        // hash路由原理***************************
        // 监听hashchange方法
        window.addEventListener('hashchange',()=>{
            div.innerHTML = location.hash.slice(1)
        })
        // history路由原理************************
        // 利用html5的history的pushState方法结合window.popstate事件（监听浏览器前进后退）
        function routerChange (pathname){
            history.pushState(null,null,pathname)
            div.innerHTML = location.pathname
        }
        window.addEventListener('popstate',()=>{
            div.innerHTML = location.pathname
        })
</script>
```





### Vue router 原理, 哪个模式不会请求服务器

**参考答案：**

Vue router 的两种方法，hash模式不会请求服务器

**解析：**

1. url的hash，就是通常所说的锚点#，javascript通过hashChange事件来监听url的变化。比如这个 URL：<http://www.abc.com/#/hello>，hash 的值为#/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此**改变 hash 不会重新加载页面**。
2. HTML5的History模式，它使url看起来像普通网站那样，以“/”分割，没有#，单页面并没有跳转。不过使用这种模式需要服务端支持，服务端在接收到所有请求后，都只想同一个html文件，不然会出现404。因此单页面应用只有一个html，整个网站的内容都在这一个html里，通过js来处理。




### 组件通信的方式

**参考答案：**

组件通信的方式的方式有以下8种方法：

1. props和$emit

   这是最最常用的父子组件通信方式，父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的

2. ![img](https://www.nowcoder.com/equation?tex=attrs%E5%92%8C&preview=true)listeners

   第一种方式处理父子组件之间的数据传输有一个问题：如果多层嵌套，父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢?

   如果采用第一种方法，我们必须让组件A通过prop传递消息给组件B，组件B在通过prop传递消息给组件C;要是组件A和组件C之间有更多的组件，那采用这种方式就很复杂了。从Vue 2.4开始，提供了![img](https://www.nowcoder.com/equation?tex=attrs%E5%92%8C&preview=true)listeners来解决这个问题，能够让组件A之间传递消息给组件C。

3. v-model

   父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input',val)自动修改v-model绑定的值

4. provide和inject

   父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。

5. 中央事件总线bus

   上面方式都是处理的父子组件之间的数据传递，那如果两个组件不是父子关系呢?也就是兄弟组件如何通信?

   这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.![img](https://www.nowcoder.com/equation?tex=emit%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%EF%BC%8Cbus.&preview=true)on监听触发的事件。

   ![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128629803/500809B9BD071EA8067678D9EC046261)

6. vuex处理组件之间的数据交互

   如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的





### vue生命周期中异步加载在mouted还是create里实现

**参考答案:**

最常用的是在 created 钩子函数中调用异步请求

**解析：**

**最常用的是在 created 钩子函数中调用异步请求**，因为在 created 钩子函数中调用异步请求有两个优点：
第一点：能更快获取到服务端数据，减少页面 loading 时间；
第二点：放在 created 中有助于一致性，因为ssr 不支持 beforeMount 、mounted 钩子函数。





### vue keep-alive

**参考答案：**

**keep-alive**：keep-alive可以实现组件缓存，是Vue.js的一个内置组件。

作用：

1. 它能够把不活动的组件实例保存在内存中，而不是直接将其销毁
2. 它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中

使用方式：

1. 常用的两个属性include/exclude，允许组件有条件的进行缓存。
2. 两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。
3. keep-alive的中还运用了LRU(Least Recently Used)算法。

原理：Vue 的缓存机制并不是直接存储 DOM 结构，而是将 DOM 节点抽象成了一个个 VNode节点，所以，keep- alive的缓存也是基于VNode节点的而不是直接存储DOM结构。

其实就是将需要缓存的VNode节点保存在this.cache中／在render时,如果VNode的name符合在缓存条件（可以用include以及exclude控制），则会从this.cache中取出之前缓存的VNode实例进行渲染。





### 生命周期

![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128702563/F5DFA24F5FDFC338D5D73739BF09C491)



### 既然函数是引用类型，为什么 vue 的 data 还是可以用函数

**参考答案：**

**JavaScript只有函数构成作用域**(注意理解作用域，**只有函数{}构成作用域**,对象的{}以及if(){}都不构成作用域),**data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响。**





### vue 中 $nextTick 作用与原理

**参考答案:**

在Vue中，==Vue是异步更新DOM的(为了提升性能)==

这时可能出现如下问题：

我们在修改DOM元素后想立刻对新更新的元素进行操作，我们可能发现获取的元素为undefined

这即是因为**Vue的异步**

**$nextTick**可以等到DOM更新后，才会触发执行此方法内的函数体





### v-if v-show区别

**参考答案：**

v-show和v-if都是用来显示隐藏元素，v-if还有一个v-else配合使用，两者达到的效果都一样，但是v-if更消耗性能的，因为v-if在显示隐藏过程中有DOM的添加和删除，v-show就简单多了，只是操作css。

**解析：**

v-show

v-show不管条件是真还是假，第一次渲染的时候都会编译出来，也就是标签都会添加到DOM中。之后切换的时候，通过display: none;样式来显示隐藏元素。可以说只是改变css的样式，几乎不会影响什么性能。

v-if

在首次渲染的时候，如果条件为假，什么也不操作，页面当作没有这些元素。当条件为真的时候，开始局部编译，动态的向DOM元素里面添加元素。当条件从真变为假的时候，开始局部编译，卸载这些元素，也就是删除。





### Vue 列表为什么加 key

**参考答案：**

vue中列表循环需加:key="唯一标识" 唯一标识且最好是静态的(不推荐index，因为可能增删元素后下标改变)，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM

[vue中v-for为何要加key？index为何不推荐作为key - 掘金 (juejin.cn)](https://juejin.cn/post/7156507746555133965?searchId=20231111195950BFE85E113F6829FADD5C)

需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点。主要是为了高效的更新虚拟DOM。





###  vue首屏白屏如何解决？

**参考答案**：

1. 路由懒加载
2. vue-cli开启打包压缩 和后台配合 gzip访问
3. 进行cdn加速
4. 开启vue服务渲染模式
5. 用webpack的externals属性把不需要打包的库文件分离出去，减少打包后文件的大小
6. 在生产环境中删除掉不必要的console.log

```javascript
  plugins: [
    new webpack.optimize.UglifyJsPlugin({ //添加-删除console.log
      compress: {
        warnings: false,
        drop_debugger: true,
        drop_console: true
      },
      sourceMap: true
    }),
```

1. 开启nginx的gzip ,在nginx.conf配置文件中配置

```javascript
http {  //在 http中配置如下代码，
   gzip on;
   gzip_disable "msie6"; 
   gzip_vary on; 
   gzip_proxied any;
   gzip_comp_level 8; #压缩级别
   gzip_buffers 16 8k;
   #gzip_http_version 1.1;
   gzip_min_length 100; #不压缩临界值
   gzip_types text/plain application/javascript application/x-javascript text/css
    application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;
 }
```

1. 添加loading效果，给用户一种进度感受





### 路由跳转和location.href的区别？

**参考答案**：

使用location.href='/url'来跳转，简单方便，但是刷新了页面；
使用路由方式跳转，无刷新页面，静态跳转；





### vue单页面和传统的多页面区别？

**参考答案**:

单页面应用（SPA）

通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。

多页面（MPA）

指一个应用中有多个页面，页面跳转时是整页刷新

**单页面的优点：**

用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。





### delete与vue.delete区别?

delte会删除数组的值，但是它依然会在内存中占位置
而vue.delete会删除数组在内存中的占位

```javascript
let arr1 = [1,2,3]
let arr2 = [1,2,3]
delete arr1[1]
this.$delete(arr2,2)
console.log(arr1)    //【1, empty, 3】
console.log(arr2)    //【1,2】
```





### computed和watch的区别

**参考答案**：

computed

计算结果并返回，只有当被计算的属性发生改变时才会触发（即：计算属性的结果会被**缓存**，除非依赖的响应属性变化才会重新及孙）

watch

监听某一个值，当被监听的值发生变化时，执行相关操作。

与computed的区别是，watch更加适用于监听某一个值的变化，并做对应操作，比如请求后台接口等。而computed适用于计算已有的值并返回结果。 监听简单数据类型：

```javascript
data(){      
    return{        
        'first':2     
    }   
},   
 watch:{      
     first(){        
         console.log(this.first)    
    }   
 },
```



# 业务

## 业务场景

### 接口兼容性问题

在实际开放中，项目上线后，我们可能对其进行升级，接口的请求或者响应可能被改变，而在客户端(用户)不一定升级为最新版本，我们需要对旧版本进行兼容，解决的思路之一就是==给接口加版本号字段==

例如：

在1.0版本，有一个接口:

```json
{
    "method": "get_user_info",
    "params": {
        "id":12345,
        "name": "xp"
    }
}
```

id和name字段都是必须字段。服务端的代码会对这两个字段进行检查。

```java
jsonParser parser(req);
if(parser.has("id")==false ) {
    // error handle
}

if(parser.has("name")==false ) {
    // error handle
}
```

如果不存在就报错返回。接口升级到1.1后，接口增加了字段 age。

```json
{
    "method": "get_user_info",
    "params": {
        "id":12345,
        "age":12345,
        "name": "xp"
    }
}
```

这个时候如果客户端还是旧版本，服务端仍然检测这个这个字段就会出问题。

```json
jsonParser parser(req);
if(parser.has("id")==false ) {
    // error handle
}

if(parser.has("name")==false ) {
    // error handle
}
if(parser.has("age")==false ) {
    // error handle
}
```

解决办法之一是在请求或响应中加入version版本字段，因此服务端可以得到不同的版本值进行不同的判断处理

```json
{
    "method": "get_user_info",
    "params": {
        "id":12345,
        "age":12345,
        "version":1,
        "name": "xp"
    }
}
```

我们根据这个版本号来决定是否检测age字段。同时客户端对这个接口进行请求时，必须传version字段。

那么旧的客户端传的版本号1，新的客户端传的是版本号2。我们的代码如下：

```java
jsonParser parser(req);
if(parser.has("version")==false ) {
    // error handle
}

if(version==1) {
    int id=parser.get("id");
    string name=parser.get("name");
}
if(version==2) {
    int age=parser.get("age");
}
```



### 班级码如何实现不重复

首先在前端上展示班级码不再是直接展示，而是采用二维码的形式，然后将班级码隐含在二维码中，班级码的生成可以==结合时间戳==生成





# 计算机基础

## 设计模式

### 单例模式

单例类只能有一个实例；单例类必须自己创建自己的唯一实例；单例类必须给所有其他对象提供这一实例

- 目的：保证一个类仅有一个实例，并提供一个访问它的全局访问点
- 主要解决：一个全局使用的类频繁地创建与销毁问题
- 优点：内存中只有一个实例，节省系统资源，尤其是频繁创建和销毁实例；避免对资源的多重占用
- 缺点：没有接口，不能继承，与类的单一职责原则冲突（一个类只应该关心内部逻辑而不关心外部如何实例化）



### 观察者模式/发布订阅模式

对象间存在一对多关系

- 目的：当一个对象被修改时，则会自动通知它的依赖对象
- 主要解决：一个对象状态改变给其他对象通知的问题，且要考虑易用和低耦合，保证高度的协作
- 优点：观察者和被观察者是依赖的（紧耦合）
- 缺点：观察者仅能知道目标对象发生了变化，而不知道是怎么发生变化的；如果观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能会导致系统崩溃；被观察对象如果有很多直接或间接的观察者的话，将所有观察者都通知到会花费很多时间

**观察者模式JS实现**

```javascript
let observer_ids=0;
//观察者类
class Observer {
   constructor() {
      this.id = observer_ids++;
   }
   //观测到变化后的处理
   update(ob){
      console.log("观察者" + this.id + `-检测到被观察者${ob.id}变化`);
   }
}
//被观察者列
class Observed {
   constructor() {
      this.observers = [];
      this.id=observed_ids++;
   }
   //添加观察者
   addObserver(observer) {
      this.observers.push(observer);
   }
   //删除观察者
   removeObserver(observer) {
      this.observers = this.observers.filter(o => {
         return o.id != observer.id;
      });
   }
   //通知所有的观察者
   notify(ob) {
      this.observers.forEach(observer => {
         observer.update(ob);
      });
   }
}

let mObserved=new Observed();
let mObserver1=new Observer();
let mObserver2=new Observer();

mObserved.addObserver(mObserver1);
mObserved.addObserver(mObserver2);

mObserved.notify();
```



### 工厂模式

- 提供创建对象的接口，意思就是根据领导（调用者）的指示（参数），生产相应的产品（对象）



### 模板模式

- 定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 通俗的讲，就是将一些公共方法封装到父类，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑



### 代理模式

- 代理模式：代理模式的中文含义就是帮别人做事，javascript的解释为：把对一个对象的访问, 交给另一个代理对象来操作.



### 外观模式

- 外观模式是很常见。其实它就是通过编写一个单独的函数，来简化对一个或多个更大型的，可能更为复杂的函数的访问。也就是说可以视外观模式为一种简化某些内容的手段





## 数据结构与算法

### 排序算法

常见排序算法分类：

![69978376609](D:\MyProject\HTMLCSSJavaScript\面试准备\assets\1699783766096.png)

- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。

**1、冒泡排序（Bubble Sort）**
冒泡排序是一种简单的排序算法，通过一趟又一趟地比较数组中的每一个元素，使较大的数据下沉，较小的数据上升。

**2、选择排序（Selection Sort）**
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

**3、插入排序（Insertion Sort）**
通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

**4、希尔排序（Shell Sort）**
希尔排序是简单插入排序的改进版，通过将数据分成不同的组，先对每一组进行排序，然后再对所有的元素进行一次插入排序，以减少数据交换和移动的次数。

**5、归并排序（Merge Sort）**
归并排序的核心思想是分而治之（Divide and Conquer）：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

**6、快速排序（Quick Sort）**
通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

**7、堆排序（Heap Sort）**
堆排序是指利用堆这种数据结构所设计的一种排序算法。堆排序会将所有的数据建成一个堆，最大的数据在堆顶，然后将堆顶数据和序列的最后一个数据交换。接下来再次重建堆，交换数据，依次下去，就可以排序所有的数据。

**8、计数排序（Counting Sort）**
计数排序核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

**9、桶排序（Bucket Sort）**
桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。

**10、基数排序（Radix Sort）**
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。

最后，附上算法复杂度的比较表：

![img](D:\MyProject\HTMLCSSJavaScript\面试准备\assets\1699783917309.png)

- **稳定**：a原本在b前面且a=b，排序之后a仍然在b的前面。
- **不稳定**：a原本在b的前面且a=b，排序之后 a 可能会出现在 b 的后面。

注：n小时，冒泡排序、交换排序、选择排序比较适用；n大时，快速排序、归并排序、堆排序比较适用；对于大部分已排序好的数列，插入排序比较适用。

参考：[十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html) [排序算法比较·面试宝典](https://troywu0.gitbooks.io/spark/content/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.html)

