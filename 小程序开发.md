# 小程序开发

[微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B)


## 起步

### 认识小程序

#### 小程序由来 
- 在起初，微信中的WebView逐渐成为移动 Web 的一个重要入口，吸引了大量开发者，但是微信所暴露的接口不能解决移动网页的体验不良问题，小程序因此诞生



#### 小程序与普通网页开发区别

1. 运行环境不同(网页运行在浏览器，而小程序运行在微信中)
2. API不同(小程序没有DOM/BOM，但是可以调用微信提供的API例如支付，扫码)
3. 开发模式不同
   1. 先申请小程序开发账号
   2. 安装官方小程序开发工具
   3. 创建项目

> 小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。
>
> - 小程序并没有一个完整浏览器对象，因而**缺少相关的DOM API和BOM API**。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。
> - 同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 **NPM 的包在小程序中也是无法运行的**。
> - 网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是**两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具**

## 开始

### 申请个人小程序账号

进入[小程序注册页](https://mp.weixin.qq.com/wxopen/waregister?action=step1) 根据指引填写信息和提交相应的资料，就可以拥有自己的小程序账号。

也可以申请一个测试账号（[开发辅助 / 测试号 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/devtools/sandbox.html)）

之后

在这个小程序管理平台，你可以管理你的小程序的权限，查看数据报表，发布小程序等操作。

登录 [小程序后台](https://mp.weixin.qq.com/) ，我们可以在菜单 “开发”-“开发设置” 看到小程序的 **AppID** 了 。



### 安装开发工具

前往 [开发者工具下载页面](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html) ，根据自己的操作系统下载对应的安装包进行安装，有关开发者工具更详细的介绍可以查看 [《开发者工具介绍》](https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html) 。

打开小程序开发者工具，用微信扫码登录开发者工具，准备开发你的第一个小程序吧！



## 小程序代码构成

这里解析小程序代码构成以最基础的JS项目为例，即项目创建时自动生成的4种文件

1. `.json` 后缀的 `JSON` 配置文件
2. `.wxml` 后缀的 `WXML` 模板文件
3. `.wxss` 后缀的 `WXSS` 样式文件
4. `.js` 后缀的 `JS` 脚本逻辑文件

接下来我们分别看看这4种文件的作用。

> ![70177863246](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701778632468.png)



### JSON配置

JSON 是一种数据格式，并不是编程语言，在小程序中，JSON扮演的静态配置的角色。

我们可以看到在项目的根目录有一个 `app.json` 和 `project.config.json`，此外在 `pages/logs` 目录下还有一个 `logs.json`，我们依次来说明一下它们的用途。

#### 小程序配置 app.json

`app.json` 是当前**小程序的全局配置**，包括了小程序的**所有页面路径、界面表现、网络超时时间、底部 tab 等**。QuickStart 项目里边的 `app.json` 配置内容如下：

```json
{
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ],
  "window":{
    "backgroundTextStyle":"light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle":"black"
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"    
}
```

我们简单说一下这个配置各个项的含义:

1. `pages`字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。
2. `window`字段 —— 定义小程序所有页面的顶部背景颜色，文字颜色定义等。
3. style字段：全局定义小程序组件所使用的样式版本
4. sitemapLocation：指明sitemap.json位置

其他配置项细节可以参考文档 [小程序的配置 app.json](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html) 。

#### 工具配置 project.config.json

通常大家在使用一个工具的时候，都会针对各自喜好做一些**个性化配置，例如界面颜色、编译配置等等**，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。

考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 `project.config.json`，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。

其他配置项细节可以参考文档 [开发者工具的配置](https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html) 。

#### 页面配置 page.json

这里的 `page.json` 其实用来表示 pages/logs 目录下的 `logs.json` 这类和小程序页面相关的配置。

如果你整个小程序的风格是蓝色调，那么你可以在 `app.json` 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了 `page.json`，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。

其他配置项细节可以参考文档 [页面配置](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE) 。



#### sitemap.json

微信运行小程序搜索，效果类似PC网页的SEO，sitemap.json文件用于配置小程序页面是否允许微信索引

当开发者允许微信索引时，微信会通过爬虫的形式，为小程序页面内容创建索引，当用户搜索关键字与页面索引匹配成功时，即小程序展现在搜索结果中



#### 新建小程序页面

- 只需在app.json中的pages结点中新增页面的存放路径，小程序开发者工具即可自动为我们创建对应文件

![70178117227](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701781172276.png)



#### 修改项目首页

只需要调整app.json的pages节点中页面路径的顺序即可修改项目首页，因为小程序会把排在第一位的页面作为首页渲染



#### JSON 语法

这里说一下小程序里JSON配置的一些注意事项。

JSON文件都是被包裹在一个大括号中 {}，通过key-value的方式来表达数据。JSON的Key必须包裹在一个双引号中，在实践中，编写 JSON 的时候，忘了给 Key 值加双引号或者是把双引号写成单引号是常见错误。

JSON的值只能是以下几种数据格式，其他任何格式都会触发报错，例如 JavaScript 中的 undefined。

1. 数字，包含浮点数和整数
2. 字符串，需要包裹在双引号中
3. Bool值，true 或者 false
4. 数组，需要包裹在方括号中 []
5. 对象，需要包裹在大括号中 {}
6. Null

还需要注意的是 JSON 文件中无法使用注释，试图添加注释将会引发报错。



### WXML模板

![70178134854](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701781348545.png)

从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中 `HTML` 是用来描述当前这个页面的结构，`CSS` 用来描述页面的样子，`JS` 通常是用来处理这个页面和用户的交互。

同样道理，在小程序中也有同样的角色，其中 `WXML` 充当的就是类似 `HTML` 的角色。打开 `pages/index/index.wxml`，你会看到以下的内容:

```html
<view class="container">
  <view class="userinfo">
    <button wx:if="{{!hasUserInfo && canIUse}}"> 获取头像昵称 </button>
    <block wx:else>
      <image src="{{userInfo.avatarUrl}}" background-size="cover"></image>
      <text class="userinfo-nickname">{{userInfo.nickName}}</text>
    </block>
  </view>
  <view class="usermotto">
    <text class="user-motto">{{motto}}</text>
  </view>
</view>
```

和 `HTML` 非常相似，`WXML` 由标签、属性等等构成。但是也有很多不一样的地方，我们来一一阐述一下：

1. 标签名字有点不一样

   往往写 HTML 的时候，经常会用到的标签是 `div`, `p`, `span`，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。

   从上边的例子可以看到，小程序的 `WXML` 用的标签是 `view`, `button`, `text` 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。

   更多详细的组件讲述参考下个章节 [小程序的能力](https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/framework.html)

2. 多了一些 `wx:if` 这样的属性以及 {{ }} 这样的表达式

   在网页的一般开发流程中，我们通常会通过 `JS` 操作 `DOM` (对应 `HTML` 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，`JS` 会记录一些状态到 `JS` 变量里边，同时通过 `DOM` API 操控 `DOM` 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。简单来说就是不要再让 `JS` 直接操控 `DOM`，`JS` 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。

   小程序的框架也是用到了这个思路，如果你需要把一个 `Hello World` 的字符串显示在界面上。

   WXML 是这么写 :

   ```html
   <text>{{msg}}</text>
   ```

   JS 只需要管理状态即可:

   ```javascript
   this.setData({ msg: "Hello World" })
   ```

   通过 {{ }} 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 `if`/`else`, `for`等控制能力，在小程序里边，这些控制能力都用 `wx:` 开头的属性来表达。

更详细的文档可以参考 [WXML](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/)

> ![70178143633](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701781436336.png)

### WXSS样式

![70178145603](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701781456038.png)

`WXSS` 具有 `CSS` 大部分的特性，小程序在 `WXSS` 也做了一些扩充和修改。

1. 新增了尺寸单位。在写 `CSS` 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。**`WXSS` 在底层支持新的尺寸单位 `rpx`** ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。
2. 提供了全局的样式和局部样式。和前边 `app.json`, `page.json` 的概念相同，你可以写一个 `app.wxss` 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 `page.wxss` 仅对当前页面生效。
3. 此外 `WXSS` 仅支持部分 `CSS` 选择器
   - .class 和 #id
   - element
   - 并集选择器、后代选择器
   - ::after和::before等伪类选择器

更详细的文档可以参考 [WXSS](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html) 。



### JS逻辑交互

一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 `JS` 脚本文件来处理用户的操作。

```html
<view>{{ msg }}</view>
<button bindtap="clickMe">点击我</button>
```

点击 `button` 按钮的时候，我们希望把界面上 `msg` 显示成 `"Hello World"`，于是我们在 `button` 上声明一个属性: `bindtap` ，在 JS 文件里边声明了 `clickMe` 方法来响应这次点击操作：

```JavaScript
Page({
  clickMe: function() {
    this.setData({ msg: "Hello World" })
  }
})
```

响应用户的操作就是这么简单，更详细的事件可以参考文档 [WXML - 事件](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html) 。

此外你还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的 QuickStart 例子中，在 `pages/index/index.js` 就调用了 [wx.getUserInfo](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserInfo.html) 获取微信用户的头像和昵称，最后通过 `setData` 把获取到的信息显示到界面上。更多 API 可以参考文档 [小程序的API](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html) 。

> ![70178170026](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701781700265.png)



## 小程序宿主环境

### 什么是宿主环境

- 我们称**微信客户端给小程序所提供的环境**为宿主环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能


![70183306788](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701833088774.png)

![70183315012](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701833150121.png)



### 小程序宿主环境包含的内容

1. 通信模型
2. 运行机制
3. 组件
4. API






### 渲染层和逻辑层

首先，我们来简单了解下小程序的运行环境。小程序的运行环境分成渲染层和逻辑层，其中 **WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层，小程序通信的主体就是渲染层和逻辑层**。

小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。

![img](https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png)

- 小程序中的**通信模型**分为两个部分(均由微信客户端进行转发)：
  - 渲染层和逻辑层之间的通信
  - 逻辑层与第三方服务器之间的通信

有关渲染层和逻辑层的详细文档参考 [小程序框架](https://developers.weixin.qq.com/miniprogram/dev/framework/MINA.html) 。



### 小程序运行机制



#### 小程序启动的过程

![70183353949](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701833539499.png)



#### 页面渲染过程

![70183357566](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701833575666.png)



### 程序与页面

微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。

紧接着通过 `app.json` 的 `pages` 字段就可以知道你当前小程序的所有页面路径:

```json
{
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ]
}
```

这个配置说明在 QuickStart 项目定义了两个页面，分别位于 `pages/index/index` 和 `pages/logs/logs`。而写在 `pages` 字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面）。

于是微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。

小程序启动之后，在 `app.js` 定义的 `App` 实例的 `onLaunch` 回调会被执行:

```javascript
App({
  onLaunch: function () {
    // 小程序启动之后 触发
  }
})
```

整个小程序只有一个 App 实例，是全部页面共享的，更多的事件回调参考文档 [注册程序 App](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html) 。

接下来我们简单看看小程序的一个页面是怎么写的。

你可以观察到 `pages/logs/logs` 下其实是包括了4种文件的，微信客户端会先根据 `logs.json` 配置生成一个界面，顶部的颜色和文字你都可以在这个 `json` 文件里边定义好。紧接着客户端就会装载这个页面的 `WXML` 结构和 `WXSS` 样式。最后客户端会装载 `logs.js`，你可以看到 `logs.js` 的大体内容就是:

```javascript
Page({//现在不是这样了！！！！！！！！！！！
  data: { // 参与页面渲染的数据
    logs: []
  },
  onLoad: function () {
    // 页面渲染后 执行
  }
})
```

`Page` 是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把 `data` 数据和 `index.wxml` 一起渲染出最终的结构，于是就得到了你看到的小程序的样子。

在渲染完界面之后，页面实例就会收到一个 `onLoad` 的回调，你可以在这个回调处理你的逻辑。

有关于 `Page` 构造器更多详细的文档参考 [注册页面 Page](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html) 。





### 组件

小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼合成自己的小程序。

就像 `HTML` 的 `div`, `p` 等标签一样，在小程序里边，你只需要在 `WXML` 写上对应的组件标签名字就可以把该组件显示在界面上，例如，你需要在界面上显示地图，你只需要这样写即可：

```html
<map></map>
```

使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，例如，我们希望地图一开始的中心的经纬度是广州，那么你需要声明地图的 longitude（中心经度） 和 latitude（中心纬度）两个属性:

```html
<map longitude="广州经度" latitude="广州纬度"></map>
```

组件的内部行为也会通过事件的形式让开发者可以感知，例如用户点击了地图上的某个标记，你可以在 `js` 编写 `markertap` 函数来处理：

```html
<map bindmarkertap="markertap" longitude="广州经度" latitude="广州纬度"></map>
```

当然你也可以通过 `style` 或者 `class` 来控制组件的外层样式，以便适应你的界面宽度高度等等。

更多的组件可以参考 [小程序的组件](https://developers.weixin.qq.com/miniprogram/dev/component/)。



#### 组件的分类

小程序中的组件也是由宿主环境提供的，开发者可以基于组件进行快速开发，官方把小程序的组件分为了9类：

1. **视图组件**
   - view
     - 即普通视图区域
     - 类似HTML的div，是块级元素
     - 用于页面布局
   - scroll-view
     - 可以滚动的视图区域
     - 用于实现滚动列表效果
   - swiper和swiper-item
     - 轮播图容器组件和轮播图item组件
     - ![70183593320](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701835933209.png)
2. **基础内容**
   - text
     - 文本组件
     - 类似于HTML中的span标签，是一个行内元素
     - ![70183625120](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701836251200.png)
   - rich-text
     - 富文本组件
     - 支持把HTML字符串渲染为WXML结构
     - ![70183631095](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701836310959.png)
   - button
     - 按钮组件
     - 通过open-type属性可以调用微信提供的各种功能(获取用户授权、信息等)
   - image
     - 图片组件
     - 默认宽约320px、高约240px 
     - ![70184538132](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701845381329.png)  
3. **表单组件**
4. **导航组件**
5. 媒体组件
6. map地图组件
7. canvas组件
8. 开放能力
9. 无障碍访问



### API

为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 给开发者去使用。

要获取用户的地理位置时，只需要：

```javascript
wx.getLocation({
  type: 'wgs84',
  success: (res) => {
    var latitude = res.latitude // 纬度
    var longitude = res.longitude // 经度
  }
})
```

调用微信扫一扫能力，只需要：

```javascript
wx.scanCode({
  success: (res) => {
    console.log(res)
  }
})
```

需要注意的是：多数 API 的回调都是异步，你需要处理好代码逻辑的异步问题。

更多的 API 能力见 [小程序的API](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html)。

#### API的分类

1. 事件监听API
   * 以on开头，用于监听某些事件的触发
   * 例如wx.onWindowResize(callbackFn)监听窗口尺寸变化的事件
2. 同步API
   - 以Sync结尾的API都是同步API
   - 同步API执行结果可以直接通过函数返回值获取，执行出错则会抛出异常
   - 例如wx.setStorageSync(key,value)进行本地存储
3. 异步API
   - 通过回调函数接收调用的结果
   - 例如wx.request()发请求，通过success回调函数接收数据




## 协同工作与发布

### 小程序成员管理的两个方面

- **管理员**对小程序**项目成员**的管理
- **管理员**对小程序**体验成员**的管理

![70186385849](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701863858499.png)



### 不同项目成员对应的权限

![70186394740](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701863947407.png)

- 开发者的权限说明：

![70186401225](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701864012252.png)

- 实际开发中，我们作为管理员可以在微信小程序后台对成员进行管理



### 小程序的版本

#### 软件开发中的不同版本

![70186430652](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701864306523.png)



#### 小程序的版本

![70186442841](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701864428414.png)



### 小程序的发布上线

- 步骤：
  - 上传代码
  - 提交审核(腾讯官方审核)
  - 发布

![70191851413](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701918514130.png)





### 基于小程序码进行推广

![70191858465](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701918584658.png)



### 运营小程序

#### 查看小程序运营数据

![70191870100](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701918701005.png)





​	

## 语法学习-模板与配置

### WXML模板语法

#### 数据绑定

1. 在data中定义数据![70191897488](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701918974880.png)
2. 在WXML中使用数据![70191899525](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701918995257.png)
   - 注意属性使用到data数据时需要使用{{}}包裹
   - ![70191925732](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701919257326.png)![70191953240](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701919532408.png)


> 补充setData:
>
> setData方法也可以直接为对象内属性赋值，语法如下
>
> ![70228360188](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702283601887.png)





#### 事件绑定

##### 常用事件

- 常用事件![70191978690](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701919786904.png)




##### 事件对象

- 事件对象event的属性列表![70191992642](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701919926426.png)
  - target与currentTarget的区别(体现在冒泡中)：![70192012085](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701920120852.png)



##### 绑定与传参
- 事件绑定语法：![70192018595](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701920185950.png)



- 在事件处理函数中修改data：![70192045776](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701920457769.png)



- 事件传参：

  - **在小程序中不允许在绑定事件的同时进行参数的传递**
  - 需要为绑定事件的组件使用**data-*自定义属性传参**，其中\*代表参数的名字![70192105060](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701921050602.png)
  - 在事件处理函数中通过e.target.dataset.参数名即可获取到对应参数的值![70192111793](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701921117938.png)

  ​




- bindinput事件语法：
  - ![70194771939](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701947719396.png)

==注意的是小程序没有什么双向绑定，都需要自己实现==




> 什么是事件：
>
> ![70191971620](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701919716206.png)



#### 条件渲染

##### wx:if

![70194838390](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701948383903.png)





##### 结合\< block \>使用wx:if

![70194873417](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701948734170.png)

实际以前我们也可以使用view标签将子标签包裹起来并进行控制显示和隐藏，不过使用\<block\>可以减少不必要的节点渲染



##### hidden

![70194893522](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701948935220.png)



##### wx:if与hidden的区别

![70194902854](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701949028545.png)





#### 列表渲染

##### wx:for

![70194939322](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701949393222.png)

> 注意：
>
> **这里的index与item的名字不是固定的，可以自行更改**
>
> ![70194951524](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701949515243.png)

##### wx:key

![70194965585](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701949655852.png)

==注意这里的wx:key以字符串形式提供==

![70219236487](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702192364876.png)



### WXSS模板样式

#### wxss与css

![70194978526](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701949785262.png)



![70194982135](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701949821355.png)





#### rpx

- rpx是微信独有的**适配屏幕的尺寸单位**

> 原理：
>
> ![70195118151](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701951181516.png)
>
> ![70195167630](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701951676309.png)



#### 样式导入

- 使用wxss提供的@import语法可以导入外部样式表
- 语法：
- ![70195176597](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701951765979.png)

#### 全局样式与局部样式

- 全局样式在app.wxss文件中，会作用于所有页面
- 局部样式只会作用于当前页面

![70195216108](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701952161087.png)





### 全局配置

#### 全局配置文件及常用配置项

![70195225483](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701952254831.png)





#### window配置项

![70195238235](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701952382355.png)

如上图所示，window配置项主要管理的是红框内容

具体常用配置属性如下

![70195250455](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701952504552.png)

  



#### tabBar

##### 什么是tabBar

![70195319175](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701953191756.png)



##### tabBar的6个组成部分

![70195329177](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701953300278.png)





##### 配置项

![70195336492](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1701953364922.png)

注意这里的list配置项是必须的，list内每个tab配置项如下：

![70203457161](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702034571619.png)



### 页面配置

小程序中，每个页面都有自己的.json配置文件，用于对**当前页面**的窗口外观、效果等进行配置

- 常用配置项如下：

![70203512812](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702035128120.png)







### 网络请求

#### 小程序的限制

- 出于安全考虑，小程序对接口数据的请求做出了限制：
  - **只能请求HTTPS类型接口**
  - **必须先将接口的域名添加到信任列表中**





#### 配置request合法域名

![70203579570](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702035795706.png)





#### get请求

![70203680879](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702036808790.png)



#### post请求

![70203706063](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702037060633.png)



#### 页面加载时请求资源

![70203708375](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702037083752.png)





#### 临时跳过request合法域名校验

![70203732564](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702037325641.png)



#### 关于跨域和Ajax的说明

![70203740086](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702037400867.png)





## 视图与逻辑

### 页面导航

#### 两种实现方式

##### 声明式导航

1. 声明式导航
   - 在页面上使用\<navigation\>导航组件(点击跳转)
   - 导航到tabBar页面![70212140029](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702121400297.png)
   - 导航到非tabBar页面(其中open-type="navigate"属性可以省略 )![70212157233](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702121572335.png)
   - 后退导航![70212177406](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702121774061.png)




##### 编程式导航

1. 编程式导航
   - 调用小程序的导航API实现跳转
   - 跳转到tabBar页面(==这里的url必须以根路径开头==)![70212206086](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702122060868.png)
   - 跳转到非tabBar页面![70212209175](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702122091753.png)
   - 后退导航![70212220188](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702122201889.png)





#### 导航传参

1. 声明式导航传参![70212241486](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702122414868.png) 
2. 编程式导航传参(switchTab不能携带参数)![70212253624](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702122536240.png)



- 接收导航参数![70212274178](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702122741785.png)





### 页面事件

#### 下拉刷新事件

##### 开启下拉刷新

首先需要明确的是，所有的小程序页面默认都不会开启下拉刷新，需要我们进行配置开启![70212297766](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702122977664.png)



##### 监听下拉刷新

- 监听页面的下拉刷新事件![70212317282](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702123172827.png)





##### 停止下拉刷新

- 在处理完下拉刷新后，使用wx.stopPullDownRefresh()即可停止loading效果





#### 上拉触底事件

![70212378859](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702123788595.png)

 ##### 监听上拉触底

![70212389545](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702123895453.png)

> 通常下拉触底时，我们会发请求获取页面数据，但是为了避免用户频繁触底，请求多次不必要，因此此时多做==节流==处理



##### 配置上拉触底距离

![70212407934](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702124079349.png)





### 生命周期

#### 什么是声明周期

![70217912303](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702179123036.png)



#### 生命周期分类

- 应用生命周期
  - 特指小程序从启动->运行->销毁的过程
- 页面生命周期
  - 特指小程序每个页面的加载->渲染->销毁的过程

![70217925757](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702179257576.png)







#### 生命周期函数

![70217932056](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702179320562.png)





#### 生命周期函数的分类

![70217936896](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702179368964.png)



##### 应用的生命周期函数

![70217958675](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702179586753.png)

这里的onLaunch函数内部可以用于进行**一些数据的初始化，例如从本地存储中读取数据**



##### 页面的生命周期函数

![70217987988](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702179879889.png)

这里使用较多的生命周期函数是onLoad和onReady(onLoad用于一开始就发请求获取数据，onReady适用于页面第一次渲染完成就修改页面navigationBarTitle)



### WXS脚本

#### 什么是WXS

WXS(即WeiXin Script)是小程序独有的脚本语言，结合WXML，可以构建出页面结构



#### WXS的应用场景

![70218024677](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702180246772.png)

==理解：即在wxml页面中不能这样``{{ data.length() }}``其中data是一个字符串类型数据==



#### 区别WXS和JavaScript

![70218026816](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702180268164.png)





#### 基础语法

1. 内嵌wxs脚本

![70218121891](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702181218911.png)



2. 外联wxs脚本![70219071818](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702190718187.png)

![70218131894](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702181318946.png)



#### WXS的4个特点

1. 与JavaScript不同![70219080686](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702190806860.png)
2. 不能作为组件的事件回调![70219084110](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702190841104.png)
3. 隔离性![70219085247](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702190852472.png)
4. 性能好![70219087303](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702190873033.png)








## 进阶语法

### 自定义组件

#### 组件的创建与引用

1. 创建组件![70220584212](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702205842127.png)
2. 引用组件
   - 局部引用![70221280907](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702212809073.png)
   - 全局引用![70221299417](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702212994173.png)

> ![70221301836](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702213018362.png)



#### 组件和页面的区别

![70221311185](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702213111851.png)





#### 样式

##### 样式隔离

首先了解组件样式隔离的概念

- 组件样式隔离
  - 默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的UI结构
  - 如下图所示，组件A/C与小程序的页面之间彼此样式互不影响![70221326790](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702213267907.png)

> ==注意理解组件样式隔离：==
>
> - app.wxss中的全局样式对组件无效
> - **只有class选择器会有样式隔离效果，id选择器、属性选择器、标签选择器不会受到样式隔离影响**
> - 因此，在组件和引用组件的页面中建议只使用class选择器



##### 修改样式隔离

![70221357601](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702213576017.png)

其中，styleIsolation属性有如下可选值：

![70221360542](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702213605424.png)





#### 数据、方法与属性

##### data数据

![70228115427](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702281154277.png)



##### methods方法

![70228117969](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702281179690.png)



##### properties属性

![70228163888](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702281638883.png)





##### data VS properties

![70228185986](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702281859868.png)

**注意：这里与Vue中是不一样的，Vue中为组件所传递的数据是不可修改的**

![70228206340](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702282063402.png)





#### 数据监听器

##### 什么是数据监听器

![70228220959](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702282209598.png)



##### 基本用法

![70228267066](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702282670665.png)



##### 监听复杂数据类型

![70228270516](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702282705168.png)

> 如果需要监听的对象属性太多，可以==使用通配符**来监听对象中所有属性变化==：
>
> ![70228376892](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702283768920.png)





#### 纯数字字段

##### 什么是纯数字字段

- 即**不会用于界面渲染的data字段**
- 作用：设置纯数字字段有利于**提高界面更新性能**

![70228392498](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702283924981.png)





##### 指定纯数字字段

![70228402278](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702284022785.png)

从小程序基础库版本 [2.10.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始，也可以在页面或自定义组件的 json 文件中配置 `pureDataPattern` （这样就不需在 js 文件的 `options` 中再配置）。此时，其值应当写成字符串形式：

```json
{
  "pureDataPattern": "^_"
}
```





#### 组件的生命周期

##### 组件全部的生命周期函数

![70228440251](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702284402518.png)

其中，最重要的生命周期函数有3个，即created、attached、detached：

特点分别如下：

1. 组件实例刚刚创建完毕，created生命周期函数触发：
   - 此时还不能调用setData
   - 通常在该生命周期函数内，只应该给组件的this添加一些自定义属性字段
2. 组件完全初始化完毕、进入页面节点树后，attached生命周期函数被触发
   - 此时，this.data已经初始化完毕
   - 绝大多数初始化工作可以在此时进行（例如发请求获取初始数据）
3. 组件离开页面结点树后，detached生命周期函数被触发
   - 退出一个页面时，会触发页面各个自定义组件的detached生命周期函数
   - 此时适合做一些清理性质的工作





##### 定义生命周期函数-lifetimes结点

![70228488396](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702284883965.png) 





##### 组件所在页面的生命周期函数

**自定义组件的行为有时候依赖于页面状态的变化**，此时需要用到**组件所在页面的生命周期函数**

![70228514252](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702285142524.png)





#### 插槽

##### 什么是插槽

在自定义的wxml结构中，可以使用\<slot\>用于承载组件使用者的wxml结构

![70228554497](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702285544979.png)



##### 单个插槽

- 在小程序中，默认每个组件只允许使用一个\<slot\>进行占位，这种个数上的限制叫做单个插槽

![70237966205](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702379662056.png)



##### 多个插槽

小程序组件默认不支持使用多个插槽，因此如果要使用多个插槽之前需要先进行**配置启用多个插槽**

![70237991720](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702379917204.png)

之后，我们就可以定义并使用多个插槽了

1. 定义多个插槽

需要在组件的wxml中使用**不同的name属性**区分不同的插槽

![70238000103](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702380001036.png)

2. 使用多个插槽

在使用组件时，使用**属性slot**将节点插入到不同的\<slot\>中即可

![70238010915](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702380109154.png)





#### 父子通信

 ##### 三种方式

1. 属性绑定
   - 用于父组件向子组件的指定属性设置数据，仅能够设置JSON兼容的数据(即不能访问方法之类的)
2. 事件绑定
   - 用于子组件向父组件传递数据(任意数据)
3. 获取子组件实例
   - 父组件还可以通过this.selectComponent()获取子组件实例对象
   - 可以访问子组件任意数据/方法





##### 属性绑定

属性绑定实现了父向子传值，但是只能传递平台类型数据，无法传递方法![70238079056](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702380790560.png)

给子组件绑定属性并传递数据后，子组件在properties中声明后即可使用![70238085782](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702380857829.png)





##### 事件绑定

事件绑定实现子向父传值，可以传递任意类型数据

1. 在父组件的js中定义一个函数，这个函数以自定义事件的形式传递给子组件(是对子组件的监听)![70238139771](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702381397719.png)
2. 在父组件的wxml中，通过自定义事件的形式，将步骤1的函数引用传递给子组件![70238144233](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702381442337.png)
3.  在子组件中，通过调用this.triggerEvent('自定义事件名称'，{参数对象})将数据发送到父组件![70238158170](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702381581703.png)
4. 在父组件的js中，使用e.detail即可获取到子组件传递的数据![70238169193](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702381691937.png)





##### 获取组件实例

父组件中直接调用**this.selectComponent("id或class选择器")**获取组件实例对象，从而直接访问子组件内部的任意数据/方法(注意只能是class选择器/id选择器)

![70238357562](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702383575623.png)





#### behaviors

 ##### 什么是behaviors

即类似vue中的"mixins"，用于实现**组件之间的代码复用**

![70238366935](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702383669354.png)





##### behaviors的工作方式

每一个behaviors中可以包含一组属性、数据、生命周期函数和方法，组件引用某个behaviors时，他的属性、数据、生命周期函数和方法会被**合并到组件中**

一个组件可以引用多个behavior，behavior也可以引用其他behavior



##### 基本使用

![70238386702](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702383867029.png)

创建好之后，即可在对应需要的组件内使用**require**方法导入需要的behavior，通过behaviors结点进行挂载即可访问到behavior中的数据和方法![70238417887](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702384178873.png)



##### behavior中可用结点

![70238420824](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702384208240.png)





##### 同名字段的覆盖和组合规则

- 组件和它所引用的behavior可以包含同名的字段，此时包含如下处理规则：
  - **同名的数据字段(data)**
    - 若同名的数据字段都是对象类型，会进行对象合并；
    - 其余情况会进行数据覆盖，覆盖规则为： `引用者 behavior` > `被引用的 behavior` 、 `靠后的 behavior` > `靠前的 behavior`。（优先级高的覆盖优先级低的，最大的为优先级最高）
  - **同名的属性(properties)或方法(methods)**
    - 若组件本身有这个属性或方法，则组件的属性或方法会覆盖 `behavior` 中的同名属性或方法；
    - 若组件本身无这个属性或方法，则在组件的 `behaviors` 字段中定义靠后的 `behavior` 的属性或方法会覆盖靠前的同名属性或方法；
    - 在 2 的基础上，若存在嵌套引用 `behavior` 的情况，则规则为：`引用者 behavior` 覆盖 `被引用的 behavior` 中的同名属性或方法。
  - **同名的生命周期函数和observers**
    - 对于不同的生命周期函数之间，遵循组件生命周期函数的执行顺序；
    - 对于同种生命周期函数和同字段 observers ，遵循如下规则：
      - `behavior` 优先于组件执行；
      - `被引用的 behavior` 优先于 `引用者 behavior` 执行；
      - `靠前的 behavior` 优先于 `靠后的 behavior` 执行；
    - 如果同一个 `behavior` 被一个组件多次引用，它定义的生命周期函数和 observers 不会重复执行。









### 使用npm包

#### 小程序对npm的支持与限制

![70238546730](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702385467300.png)

==注意：最好每次安装完一个包，都进行构建一次==





#### 小程序UI组件库Vant Weapp

##### 什么是Vant Weapp

![70238554806](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702385548068.png)





### API Promise化

#### 基于回调函数的异步API缺点

默认情况下，小程序提供的官方异步API都是基于回调函数实现的![70244674512](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702446745126.png)

很明显，这样的API**容易造成回调函数地狱的问题，代码的可读性/维护性差**



#### 实现API Promise化

![70243924488](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702439244886.png)

这里我们使用npm包的函数promisifyAll将顶级对象wx里的所有API进行promise化后赋值给wxp这个对象(注意这里因为wxp与wx.p引用同一个对象，因此函数执行完毕后，我们就可以通过wx.p去调用promise化后的api了)





##### 调用Promise化后的API

![70243956433](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702439564331.png)





### 全局数据共享

#### 什么是全局数据共享

- 全局数据共享(状态管理)是为了解决组件之间数据共享的问题
- 例如Vuex、Redux、MobX等

![70244692586](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702446925860.png)





#### 小程序的全局数据共享方案

- 在小程序中，使用mobx-miniprogram配合mobx-miniprogram-bindings实现全局数据共享
  - mobx-miniprogram用于创建store实例对象
  - mobx-miniprogram-bindings用于把store中的共享数据或方法，绑定到组件或页面中使用

![70244714954](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702447149547.png)





#### 安装MobX相关包

![70244718794](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702447187945.png)







#### 创建MobX的Store实例

可以在项目目录下新建一个文件夹命名为store后创建store.js输入如下内容，导出store实例对象

![70244778037](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702447780375.png)



#### 绑定到页面中

##### 将store中的成员绑定到页面中

![70244798630](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702447986302.png)





##### 在页面上使用store成员

上述步骤都完成后，在页面上即可像正常我们已经定义的数据/方法去使用即可

![70244843391](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702448433910.png)





#### 绑定到组件中

##### 将store的成员绑定到组件中

注意这里使用的是storeBindingsBehavior而不是之前的createStoreBindings

![70244883900](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702448839001.png)



##### 在组件中使用store成员

同样的，绑定完成后，像正常已经定义好的数据去使用即可

![70244960579](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702449605792.png)





### 分包

#### 什么是分包

![70245107607](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702451076071.png)



#### 分包的好处

![70245110709](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702451107097.png)



#### 分包前后项目构成

![70245113744](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702451137443.png)

![70245118025](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702451180253.png)



#### 分包的加载规则

![70245123204](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702451232045.png)



#### 分包的体积限制

![70245127768](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702451277680.png)



#### 使用分包

##### 配置方法

如下左图是我们希望的分包情况，除了目录结构外，我们需要到app.json中进行声明分包结构(使用subpackage结点)，与主包页面的声明类似的，分包pages声明后，小程序会自动为我们创建对应的目录

![70245142706](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702451427067.png)



##### 打包原则

![70245180813](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702451808135.png)



##### 引用原则

![70245184890](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702451848902.png)



#### 独立分包

- 独立分包本质上也是分包，只不过它是特殊的分包，可以**独立于主包和其他分包而单独运行**

![70252303073](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702523030733.png)

- 与普通分包最主要的区别：是否依赖主包才能运行
  - 普通分包必须依赖主包才能运行
  - 独立分包可以在不下载主包的情况下，独立运行







##### 应用场景

![70252317269](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702523172699.png)



##### 配置独立分包

那么如何配置独立分包？？

![70252325954](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702523259544.png)





##### 引用原则

![70252337537](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702523375377.png)







#### 分包预下载

即在进入小程序的某个页面时，由框架自动预下载可以需要的分包，从而提升加入后续分包页面的启动速度

##### 配置分包预下载

![70252381187](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702523811879.png)





##### 限制

![70252426058](D:\MyProject\HTMLCSSJavaScript\小程序开发\assets\1702524260584.png)

